---
title: openssl学习记录
date: 2021-07-28 11:42:59
tags: [网络]
categories: [Program, C/C++]
top: 90
---

# 一、前言

```
PS D:\work\src\local\cpp\openssl\1.1.1> .\apps\openssl.exe
OpenSSL> version
OpenSSL 1.1.1k  25 Mar 2021
```

## 1. 证书格式解析

## 2. ssl协议解析

# 二、命令

## 1. 一些基本用法

```shell
# 枚举支持的加密套件
openssl ciphers -v
```

### 1.1. 国密openssl命令

```shell
# 列举支持的椭圆曲线
openssl_gm ecparam -list_curves
```

## 2. 证书

### 1.1. 颁发证书

#### (1) 国际密码标准（普密）

**1. 颁发证书需要先生成一个颁发机构，也就是CA**

```shell
# 新建目录防止混乱
mkdir -p ssl_diy/private && cd ssl_diy
# 生成ca的私钥
openssl genrsa -out private/cakey.pem 2048
# 根据key生成CA的证书文件
openssl req -new -x509 -days 3650 -key private/cakey.pem -out cacert.pem
# 将有一些配置需要填写，可以随意填写，因为是自颁发
# Country Name (2 letter code) [AU]: 国家名，自然CN
# State or Province Name (full name) [Some-State]: 省份名称，比如Hunan
# Locality Name (eg, city) []: 城市名称，比如changsha
# Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名称
# Organizational Unit Name (eg, section) []: 部门名称
# Common Name (eg, YOUR name) []: 颁发者的名字
# Email Address []: 邮件地址

# 也可以直接使用-subj指定subject
openssl req -new -x509 -key private/cakey.pem -out cacert.pem -subj "/C=CN/ST=Beijing/L=Haidian/O=Datang/OU=SDT/OU=abc/CN=Shixun/emailAddress=dongzy08@qq.com"

# pem转crt格式
openssl x509 -outform der -in cacert.pem -out cacert.crt
```

**2. 生成证书**

```shell
######### 生成证书 ###########
# 同样生成私钥key
openssl genrsa -out domain.key 2048
# 根据key生成证书文件
openssl req -new -key domain.key -out domain.csr
# 将有一些配置需要填写，可以随意填写，因为是自颁发
# Country Name (2 letter code) [AU]: 国家名，自然CN
# State or Province Name (full name) [Some-State]: 省份名称，比如Hunan
# Locality Name (eg, city) []: 城市名称，比如changsha
# Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名称
# Organizational Unit Name (eg, section) []: 部门名称
# Common Name (eg, server FQDN or YOUR name) []: 填写网站的域名
# Email Address []: 邮件地址

# 也可以直接使用-subj指定subject
openssl req -new -key domain.key -out domain.csr -subj "/C=CN/ST=Beijing/L=Haidian/O=Datang/OU=SDT/OU=abc/CN=Shixun/emailAddress=dongzy08@qq.com"

######### 使用ca给证书签名 ###########
# 签名前需要有几个准备文件
mkdir -p demoCA/newcerts
touch demoCA/index.txt
echo 01 > demoCA/serial
# 签名，可以自定义有效天数-days
openssl ca -in domain.csr -cert cacert.pem -keyfile private/cakey.pem -days 365 -out domain.crt

# 生成p12，需要设置密码
openssl pkcs12 -export -out domain.p12 -inkey domain.key -in domain.crt
```

#### (2) 中国密码标准（国密）

**0. 准备工作**

```shell
mkdir -p ssl_diy/private
cd ssl_diy
```

**1. 生成用户证书**

1. 根据椭圆曲线生成密钥

```shell
openssl_gm ecparam -genkey -name SM2 -out private/root-cakey.pem
```

- 生成的密钥内容如下

```
-----BEGIN EC PARAMETERS-----
BggqgRzPVQGCLQ==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIPS25CUNA9sedtqmVHAkIBhknFUAREy5+eEfg/vkX30noAoGCCqBHM9V
AYItoUQDQgAEnnSjGFJ3LG1qA7wYGpnRxr6palpBtuw4yToNW7QRZKz12s438i1G
Dqxf97ZcfeI6pAxb+e4TOSLu7tIt+wFyng==
-----END EC PRIVATE KEY-----
```

#### (3) 生成带拓展字段的证书

- 需要拷贝一份`/etc/ssl/openssl.cnf`文件到自己的目录下
- 修改里面的字段，添加下面的字段

```ini
[ v3_req ]
# 添加下面语句
subjectAltName = @alt_names
...
# 添加下面块，DNS加几个自己决定
[ alt_names ]
DNS.1 = www.test.com
DNS.2 = *.aaa.com
```

- 然后在生成证书（非生成CA）的命令中加上`-config /path/to/openssl.cnf`
- 签名命令中加上`-config /path/to/openssl.cnf -extensions v3_req`

### 1.2. 证书转换

**p12**

- p12是证书和私钥结合的证书，一般作为设备证书导入使用或者导入为浏览器证书做证书认证使用

```shell
########## 解开p12证书 ##########
# 只要证书，需要密码
openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem
# 只要私钥
openssl pkcs12 -nocerts -nodes -in cert.p12 -out key.pem

########## 生成p12证书 ##########
# 需要私钥+证书生成，需要设置密码
openssl pkcs12 -export -out domain.p12 -inkey domain.key -in domain.crt
```

**cer/crt转其他**

- cer和crt是同一种格式，只是后缀不同
- 都为二进制格式
- 证书为CA时一般作为校验客户端证书使用

```shell
# ca类型证书转pem
openssl x509 -inform der -in cert.cer -out cert.pem
```

**pem转其他**

- pem为ascii字符的形式

```shell
# cer/crt
openssl x509 -outform der -in cert.pem -out cert.cer
```

### 1.3. 验证证书

```shell
# 使用ca根证书校验客户端证书
openssl verify -CAfile root.crt client.pem
```

### 1.4. 查看证书

- oid的对照关系可以看`node-forge/lib/oids.js`

```shell
# 打印证书内容，下面命令传入的是ascii字符版证书
openssl x509 -in cert.pem -noout -text
```

## 3. 客户端 `openssl s_client`

### 2.1. 选项

- `-engine <name>`: 使用引擎，给一些使用硬件加密的代码使用
- `-ssl_client_engine <name>`: 使用引擎给客户端需要证书操作时
- `-connect <ip:port>`: 连接地址，仅支持ip+端口，不支持url
- `-msg`: 显示协议相关的消息体
- `-state`: 显示当前ssl的阶段
- `-debug`: 额外显示一些输出
- `-tls1_1`: 使用tlsv1.1进行通信
- `-cipher <ciphers>`: 指定tlsv1.2及以下的套件列表
- `-ciphersuites <ciphers>`: 指定tlsv1.3套件列表
- `-key <keyPath>`: 如果证书`-cert`没有带key，需要指定私钥
- `-cert <certPath>`: 证书，pem格式
- `-servername <serverName>`: 添加tls的extension字段`server_name`

## 4. 服务端 `openssl s_server`

- `-accept <port>`: 监听端口
- `-tls1_1`: 只使用tlsv1.1
- `-cipher <ciphers>`: 指定tlsv1.2及以下的套件列表
- `-ciphersuites <ciphers>`: 指定tlsv1.3套件列表
- `-state`: 显示当前ssl的阶段
- `-CAfile <caPath>`: ca根证书路径，用于校验对端证书，pem格式
- `-key <keyPath>`: 如果证书`-cert`没有带key，需要指定私钥
- `-cert <certPath>`: 证书，pem格式
- `-verify int`: 开启校验对端证书
- `-Verify int`: 强制要求对端有证书，并开启校验

# 三、openssl库

## 1. 引擎开发指南

### 1.1. 简介

- 引擎库是openssl给一些硬件设备提供的一个标准化开发接口，可以通过编写一些硬件接口对接openssl实现ssl过程中使用硬件进行加解密等操作
- 一般引擎库再windows上放置位置为`C:\Program Files (x86)\OpenSSL\lib\engines-1_1\xxx.dll`文件，加载时会根据id找同名dll文件
- 实现上对于企业用户，使用引擎库可以作为ukey来证书认证或国密加密认证等
- ukey不管是普密还是国密，都是无法导出私钥的，证书的认证流程需要使用私钥对证书进行签名，再发送给服务端进行解析，所以引擎库里面不仅需要导出证书接口，还需要实现证书的签名接口，使用ukey的签名接口进行签名
- skf转openssl结构体参考仓库: https://github.com/guanzhi/GmSSL

### 1.2. 基础接口

- 加载引擎必须要定义的下面几个函数

```cpp
/******************** 这个函数是引擎设置的最基础的函数 ********************/

/* Constants used when creating the ENGINE */
static const char* engine_id = "skf";

/* Prepare the ENGINE structure for registration */
static int skf_bind_helper(ENGINE* e) {
    LOG_DEBUG(Tag, "skf_bind_helper");

    // 设置引擎的id
    if (!ENGINE_set_id(e, engine_id) ||
        !ENGINE_set_name(e, engine_name) ||
        // 引擎加载时调用
        !ENGINE_set_init_function(e, engine_init) ||
        // 设置EC加密算法相关的函数
        !ENGINE_set_EC(e, &skf_ecc_meth) ||
        // if not set, skf will load by default if possible
        !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||
        !ENGINE_set_destroy_function(e, engine_destroy) ||
        !ENGINE_set_finish_function(e, engine_finish) ||
        !ENGINE_set_ctrl_function(e, engine_ctrl) ||
        !ENGINE_set_cmd_defns(e, engine_cmd_defns) ||
        !ENGINE_set_load_privkey_function(e, engine_load_key) ||
        // 加载客户端证书的函数
        !ENGINE_set_load_ssl_client_cert_function(e,
                                                  skf_load_ssl_client_cert)) {
        return 0;
    }

    return 1;
}

/****************** 下面是给openssl库的标准接口，必须定义的 ********************/

/* This stuff is needed if this ENGINE is being compiled into a self-contained
 * shared-library. */
#ifndef OPENSSL_NO_DYNAMIC_ENGINE
#include <openssl/engine.h>
static int bind_helper(ENGINE* e, const char* id) {
    if (id && (strcmp(id, engine_id) != 0)) return 0;

    if (!skf_bind_helper(e)) return 0;

    return 1;
}

IMPLEMENT_DYNAMIC_CHECK_FN()
IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
#else
static ENGINE* engine_skf(void) {
    ENGINE* eng = ENGINE_new();
    if (!eng) return NULL;
    if (!skf_bind_helper(eng)) {
        ENGINE_free(eng);
        return NULL;
    }

    return eng;
}

void engine_load_skf_int(void) {
    ENGINE* toadd = engine_skf();
    if (!toadd) return;
    ENGINE_add(toadd);
    ENGINE_free(toadd);
    ERR_clear_error();
}
#endif /* OPENSSL_NO_DYNAMIC_ENGINE */
```

- 编译出来的引擎库名字和设置中的`engine_id`要一致

### 1.3. 加载引擎

**libcurl调用**

- curl引擎设置如下

```cpp
size_t curlWriteFunction(void *ptr, size_t size /*always==1*/, size_t nmemb,
                         void *userdata) {
    char **stringToWrite = (char **)userdata;
    const char *input = (const char *)ptr;
    if (nmemb == 0) return 0;
    if (!*stringToWrite)
        *stringToWrite = (char *)malloc(nmemb + 1);
    else
        *stringToWrite = (char *)realloc(*stringToWrite, dataSize + nmemb + 1);
    memcpy(*stringToWrite + dataSize, input, nmemb);
    dataSize += nmemb;
    (*stringToWrite)[dataSize] = '\0';
    return nmemb;
}

/* The SSL initialisation callback. The callback sets:
   - a private key and certificate
   - a trusted ca certificate
   - a preferred cipherlist
   - an application verification callback (the function above)
*/
static CURLcode sslctxfun(CURL *curl, void *sslctx, void *parm) {
    SSL_CTX *ctx = (SSL_CTX *)sslctx;
    ENGINE *ssl_client_engine = NULL;

    do {
        ssl_client_engine = ENGINE_by_id("skf");
        if (ssl_client_engine == NULL) {
            fprintf(stderr, "get engine failed\n");
            break;
        }
        if (!SSL_CTX_set_client_cert_engine(ctx, ssl_client_engine)) {
            fprintf(stderr, "Error setting client auth engine\n");
            break;
        }
        return CURLE_OK;
    } while (false);
    ENGINE_free(ssl_client_engine);

    return CURLE_FAILED_INIT;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stdout, "Usage: curl_engine.exe <URL>\n");
        fprintf(stdout, "\texample: curl_engine.exe https://xxx.xxx.xxx.xxx\n");
        return 0;
    }

    char *data = 0;
    CURL *const curl = curl_easy_init();
    if (!curl) {
        fprintf(stderr, "Failed to init curl");
        return 1;
    }
    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);

    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

    /******************** 引擎加载选项 begin ********************/
    // 设置curl加载引擎
    curl_easy_setopt(curl, CURLOPT_SSLENGINE, "skf");
    // 设置curl将默认算法使用引擎提供的算法
    curl_easy_setopt(curl, CURLOPT_SSLENGINE_DEFAULT, 1L);
    // 如果需要使用引擎中的客户端提供证书接口，需要设置此选项
    curl_easy_setopt(curl, CURLOPT_SSL_CTX_FUNCTION, sslctxfun);
    /******************** 引擎加载选项 end ********************/

    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 3 * 1000);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 3 * 1000);

    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);

    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &data);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &curlWriteFunction);

    CURLcode mc = curl_easy_perform(curl);
    if (mc != CURLE_OK) {
        fprintf(stderr, "Failed to get web page, curl error: %s\n",
                curl_easy_strerror(mc));
        return 1;
    }
    curl_easy_cleanup(curl);

    if (!data) {
        fprintf(stderr, "Got no data\n");
        return 1;
    }

    printf("Page data:\n\n%s\n", data);
    free(data);
}
```

### 1.4. 测试命令

```shell
# 服务端监听命令，重点是-CAfile需要使用ukey里面的证书对应的ca根证书
openssl s_server -accept 777 -tls1_1 -state -debug -cipher ECC-SM4-SM3 -state -key ./apps/certs/sm2sign.key -cert ./apps/certs/sm2sign.crt -ekey ./apps/certs/sm2enc.key -ecert ./apps/certs/sm2enc.crt -CAfile ./apps/certs/server.crt -Verify 1
# 客户端请求使用skf引擎
openssl s_client -engine skf -ssl_client_engine skf -connect 127.0.0.1:777 -state -cipher ECC-SM4-SM3
```

### 1.5. 使用skf接口实现rsa引擎

- openssl的rsa签名校验原理先看 [rsa签名与校验](#4-rsa签名与校验)，后文对于相关的知识讲解会略过
- [skf接口文档](https://max.book118.com/html/2018/0618/173250950.shtm)

#### 1) 需要用到的skf引擎的关键函数

```cpp
// 导出证书
// bSignFlag TRUE为签名证书，FALSE为加密证书
ULONG DEVAPI SKF_ExportCertificate(HCONTAINER hContainer, BOOL bSignFlag,
                                   BYTE *pbCert, ULONG *pulCertLen);
// 导出证书的公钥
// bSignFlag TRUE为签名证书，FALSE为加密证书
ULONG DEVAPI SKF_ExportPublicKey(HCONTAINER hContainer, BOOL bSignFlag,
                                 BYTE *pbBlob, ULONG *pulBlobLen);
// 使用签名证书的私钥进行签名
ULONG DEVAPI SKF_RSASignData(HCONTAINER hContainer, BYTE *pbData,
                             ULONG ulDataLen, BYTE *pbSignature,
                             ULONG *pulSignLen);
// 获取容器类型，1为rsa，2为ecc
ULONG DEVAPI SKF_GetContainerType(HCONTAINER hContainer,
                                  ULONG *pulContainerType);
```

#### 2) skf导出数据到openssl结构体的工具函数

```cpp
// 将导出的公钥结构体设置到rsa结构体的公钥部分
int RSA_set_RSAPUBLICKEYBLOB(RSA *rsa, const RSAPUBLICKEYBLOB *blob)
{
	int ret = 0;
	BIGNUM *n = NULL;
	BIGNUM *e = NULL;

	if (!rsa || !blob) {
        LOG_ERROR(Tag, "!rsa || !blob");
		return 0;
	}

	if ((blob->BitLen < OPENSSL_RSA_FIPS_MIN_MODULUS_BITS)
		|| (blob->BitLen > sizeof(blob->Modulus) * 8)
		|| (blob->BitLen % 8 != 0)) {
        LOG_ERROR(Tag, "blob->BitLen < OPENSSL_RSA_FIPS_MIN_MODULUS_BITS");
		return 0;
	}

    // 导出两个大质数的乘积n
	if (!(n = BN_bin2bn(blob->Modulus, sizeof(blob->Modulus), NULL))) {
        LOG_ERROR(Tag, "n = BN_bin2bn(blob->Modulus, sizeof(blob->Modulus), NULL)");
		goto end;
	}

    // 导出公钥的e
	if (!(e = BN_bin2bn(blob->PublicExponent,
		sizeof(blob->PublicExponent), NULL))) {
        LOG_ERROR(Tag, "e = BN_bin2bn(blob->PublicExponent");
		goto end;
	}

    // 设置rsa的n和e，对应的是rsa算法的公钥部分
	if (!RSA_set0_key(rsa, n, e, NULL)) {
        LOG_ERROR(Tag, "RSA_set0_key(rsa, n, e, NULL)");
		goto end;
	}
	n = NULL;
	e = NULL;

	ret = 1;

end:
	BN_free(n);
	BN_free(e);
	return ret;
}
```

#### 3) openssl中需要用到的一些函数和结构体讲解

```cpp
/********** include/openssl/rsa.h **********/
// 获取openssl内置的默认rsa_method
const RSA_METHOD *RSA_get_default_method(void);
// 将已有的rsa_method拷贝一份，防止修改到原始的结构体
RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth);

/********** include/openssl/engine.h **********/
// 在引擎中设置rsa_meth，skf接口需要自定义一些算法，所以要自定义rsa_meth
int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);
// 设置加载客户端证书的函数，这里要自定义从skf接口取出证书
int ENGINE_set_load_ssl_client_cert_function(ENGINE *e,
                                             ENGINE_SSL_CLIENT_CERT_PTR
                                             loadssl_f);
```

- `rsa_method`是非导出的，具体的内容如下

```cpp
// crypto/rsa/rsa_local.h

struct rsa_meth_st {
    char *name;
    // 公钥加密函数
    int (*rsa_pub_enc) (int flen, const unsigned char *from,
                        unsigned char *to, RSA *rsa, int padding);
    // 公钥解密函数
    int (*rsa_pub_dec) (int flen, const unsigned char *from,
                        unsigned char *to, RSA *rsa, int padding);
    // 私钥加密函数
    int (*rsa_priv_enc) (int flen, const unsigned char *from,
                         unsigned char *to, RSA *rsa, int padding);
    // 私钥解密函数
    int (*rsa_priv_dec) (int flen, const unsigned char *from,
                         unsigned char *to, RSA *rsa, int padding);
    // 默认私钥解密函数中用到的模解密函数，rsa->flags控制使用哪一个
    /* Can be null */
    int (*rsa_mod_exp) (BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx);
    // 和上面一样默认私钥解密函数中用到的模解密函数，用到的是n和d
    /* Can be null */
    int (*bn_mod_exp) (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                       const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
    /* called at new */
    int (*init) (RSA *rsa);
    /* called at free */
    int (*finish) (RSA *rsa);
    /* RSA_METHOD_FLAG_* things */
    int flags;
    /* may be needed! */
    char *app_data;
    /*
     * New sign and verify functions: some libraries don't allow arbitrary
     * data to be signed/verified: this allows them to be used. Note: for
     * this to work the RSA_public_decrypt() and RSA_private_encrypt() should
     * *NOT* be used RSA_sign(), RSA_verify() should be used instead.
     */
    int (*rsa_sign) (int type,
                     const unsigned char *m, unsigned int m_length,
                     unsigned char *sigret, unsigned int *siglen,
                     const RSA *rsa);
    int (*rsa_verify) (int dtype, const unsigned char *m,
                       unsigned int m_length, const unsigned char *sigbuf,
                       unsigned int siglen, const RSA *rsa);
    /*
     * If this callback is NULL, the builtin software RSA key-gen will be
     * used. This is for behavioural compatibility whilst the code gets
     * rewired, but one day it would be nice to assume there are no such
     * things as "builtin software" implementations.
     */
    int (*rsa_keygen) (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
    int (*rsa_multi_prime_keygen) (RSA *rsa, int bits, int primes,
                                   BIGNUM *e, BN_GENCB *cb);
};
```

- openssl的默认`rsa_method`如下

```cpp
// crypto/rsa/rsa_ossl.c

static RSA_METHOD rsa_pkcs1_ossl_meth = {
    "OpenSSL PKCS#1 RSA",
    rsa_ossl_public_encrypt,
    rsa_ossl_public_decrypt,     /* signature verification */
    rsa_ossl_private_encrypt,    /* signing */
    rsa_ossl_private_decrypt,
    rsa_ossl_mod_exp,
    BN_mod_exp_mont,            /* XXX probably we should not use Montgomery
                                 * if e == 3 */
    rsa_ossl_init,
    rsa_ossl_finish,
    RSA_FLAG_FIPS_METHOD,       /* flags */
    NULL,
    // sign和verify标0代表使用默认签名和校验函数，而非不使用
    0,                          /* rsa_sign */
    0,                          /* rsa_verify */
    NULL,                       /* rsa_keygen */
    NULL                        /* rsa_multi_prime_keygen */
};

static const RSA_METHOD *default_RSA_meth = &rsa_pkcs1_ossl_meth;
```

#### 4) 结合skf和openssl的原理讲解一下

- 使用skf引擎一般是使用ukey进行证书双向认证，双向认证的流程解析查看 [双向认证流程](#2-双向认证流程)
- ukey保证安全性，私钥是不允许导出的，所以**私钥签名**这一步需要自己实现
- 证书存在于ukey中，所以需要修改**加载证书**的函数
- 私钥解密不需要，因为双向认证过程中没有服务端使用客户端上传的公钥加密的过程
- 公钥加密在客户端角度是使用服务端的公钥加密上传的数据，这里软件实现即可，不需要ukey的硬件实现
- 公钥解密同样软件实现即可

#### 5) 引擎设置代码

```cpp
static int skf_load_rsa_client_cert(X509** pcert, EVP_PKEY** ppkey) {
    const char* operation = "load rsa client cert";
    RSAPUBLICKEYBLOB pubKey = {0};
    EVP_PKEY* pkey = NULL;
    RSA* r = NULL;
    int iResult = 0;
    unsigned char certContetBITS[8192] = {0};
    ULONG ulCertLen = sizeof(certContetBITS);
    BIO* b = NULL;

    LOG_INFO(Tag, "%s", operation);
    do {
        if ((pkey = EVP_PKEY_new()) == NULL) {
            LOG_ERROR(Tag, "[%s] new EVP_PKEY failed", operation);
            break;
        }

        // 导出公钥写入算法结构体
        if (exportPublicKey(TRUE, reinterpret_cast<unsigned char*>(&pubKey), sizeof(pubKey)) < 0) {
            LOG_ERROR(Tag, "[%s] export public key from skf failed", operation);
            break;
        }
        LOG_INFO(Tag, "export public key success");

        if ((r = RSA_new()) == NULL) {
            LOG_ERROR(Tag, "[%s] new RSA failed", operation);
            break;
        }

        if (!RSA_set_RSAPUBLICKEYBLOB(r, &pubKey)) {
            LOG_ERROR(Tag, "[%s] set public key to rsa failed", operation);
            break;
        }
        if (!EVP_PKEY_assign_RSA(pkey, r)) {
            LOG_ERROR(Tag, "[%s] assign rsa to EVP_KEY failed", operation);
            break;
        }
        *ppkey = pkey;

        // 导出签名证书写入证书指针
        if (!exportCertificate(TRUE, certContetBITS, ulCertLen)) {
            LOG_ERROR(Tag, "[%s], export sign certificate by skf failed", operation);
            break;
        }
        LOG_INFO(Tag, "export sign certificate by skf certLen[%d]", ulCertLen);

        if ((b = BIO_new(BIO_s_mem())) == NULL) {
            LOG_ERROR(Tag, "[%s], new BIO failed", operation);
            break;
        }

        BIO_write(b, certContetBITS, ulCertLen);
        *pcert = d2i_X509_bio(b, NULL);
        if (*pcert == NULL) {
            LOG_ERROR(Tag, "[%s], d2i_X509_bio failed", operation);
            break;
        }

        iResult = 1;
        LOG_INFO(Tag, "%s success", operation);
    } while (false);

    if (b != NULL) {
        BIO_free(b);
        b = NULL;
    }

    // 成功部分指针不需要清理
    if (iResult == 1) {
        return iResult;
    }

    if (r != NULL) {
        RSA_free(r);
        r = NULL;
    }

    if (pkey != NULL) {
        EVP_PKEY_free(pkey);
        pkey = NULL;
    }
    return iResult;
}

static int skf_load_ssl_client_cert(ENGINE* e, SSL* ssl, STACK_OF(X509_NAME) * ca_dn, X509** pcert,
                                    EVP_PKEY** ppkey, STACK_OF(X509) * *pother,
                                    UI_METHOD* ui_method, void* callback_data) {
    const char* operation = "skf_load_ssl_client_cert";
    LOG_DEBUG(Tag, "%s", operation);

    if (getContainerType() == 1) {
        return skf_load_rsa_client_cert(pcert, ppkey);
    }
    // only handle rsa, other return false
    return 0;
}

int skf_rsa_priv_enc(int flen, const unsigned char* from, unsigned char* to, RSA* rsa,
                     int padding) {
    LOG_DEBUG(Tag, "skf_rsa_priv_enc from len %d, padding %d", flen, padding);
    int ret = rsaDoSign(from, flen, to, 1024);
    LOG_DEBUG(Tag, "rsaDoSign ret %d", ret);
    return ret;
}

static RSA_METHOD* skf_rsa_method = NULL;
/* Prepare the ENGINE structure for registration */
static int skf_bind_helper(ENGINE* e) {
    LOG_DEBUG(Tag, "skf_bind_helper");

    // set skf rsa engine method, use default method and diy some function
    if ((skf_rsa_method = RSA_meth_dup(RSA_get_default_method())) == NULL ||
        // do not need priv_dec
        RSA_meth_set_priv_dec(skf_rsa_method, NULL) == 0 ||
        // skf provide priv_enc
        RSA_meth_set_priv_enc(skf_rsa_method, skf_rsa_priv_enc) == 0) {
        return 0;
    }

    if (!ENGINE_set_id(e, engine_epass_id) || !ENGINE_set_name(e, engine_epass_name) ||
        !ENGINE_set_init_function(e, epass_init) ||
        // set rsa method
        !ENGINE_set_RSA(e, skf_rsa_method) ||
        // if not set, sdf will load by default if possible
        !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||
        !ENGINE_set_destroy_function(e, epass_destroy) ||
        !ENGINE_set_finish_function(e, epass_finish) || !ENGINE_set_ctrl_function(e, epass_ctrl) ||
        !ENGINE_set_cmd_defns(e, epass_cmd_defns) ||
        !ENGINE_set_load_privkey_function(e, epass_load_key) ||
        // set load client cert
        !ENGINE_set_load_ssl_client_cert_function(e, skf_load_ssl_client_cert)) {
        return 0;
    }

    return 1;
}
```

### 1.6. 使用skf接口实现sm2国密引擎

## 2. 随机数生成算法

- 需要链接`-lcrypto`
- 内部会获取`/dev/urandom`、`pid`、`tid`、`时间`作为种子，所以相同种子也会有不同随机数

```cpp
#include <openssl/rand.h>

int main() {
    unsigned char buf[255] = {0};
    ...
    // 设置种子，也可以不设置，加上会增加随机性
    RAND_seed(buf, sizeof buf);

    // 使用
    unsigned char buf1[255] = {0};
    RAND_bytes(buf, sizeof buf1);

}
```

## 3. 错误信息输出

```cpp
ret = RSA_verify(NID_sha1, testmd, 20, sig, len, rsa);
if (ret != 1) {
    unsigned long e = ERR_get_error();
    char buf[255] = {0};
    LOG_ERROR("NID_sha1 verify ret {}, reason {}", ret, ERR_error_string(e, buf));
    return 0;
}
```

## 4. rsa签名与校验

RSA原理先看 [RSA算法](/blogs/2022-03-23-cryptography/#2-RSA算法)

### 4.1. 接口和结构体

```cpp
// openssl/rsa.h

/*
 * The following 2 functions sign and verify a X509_SIG ASN1 object inside
 * PKCS#1 padded RSA encryption
 */
int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
             unsigned char *sigret, unsigned int *siglen, RSA *rsa);
int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
               const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
```

- 其中`m`和`m_length`是原文数据
- `sigret`和`siglen`是加密后的数据
- `type`定义了摘要算法类型，这里是重点，传入的m并不会直接进行加密，而是先经过摘要计算一次，在进行加密
- `rsa`是算法结构体，在计算过程中可以使用到，在不同的函数需要的结构体不一样，下面讲一下算法结构体

```cpp
// include/openssl/ossl_typ.h
typedef struct rsa_st RSA;

// crypto/rsa/rsa_local.h
struct rsa_st {
    /*
     * The first parameter is used to pickup errors where this is passed
     * instead of an EVP_PKEY, it is set to 0
     */
    int pad;
    int32_t version;
    const RSA_METHOD *meth;
    /* functional reference if 'meth' is ENGINE-provided */
    ENGINE *engine; // 引擎，自定义算法时定义
    BIGNUM *n;      // 公钥和私钥都需要的数据，n=p*q
    BIGNUM *e;      // 公钥数据，验签需要
    BIGNUM *d;      // 私钥数据，加密需要
    BIGNUM *p;      // 选取的大质数，内部数据，加解密不需要这个
    BIGNUM *q;      // 选取的大质数，内部数据，加解密不需要这个
    BIGNUM *dmp1;
    BIGNUM *dmq1;
    BIGNUM *iqmp;
    /* for multi-prime RSA, defined in RFC 8017 */
    STACK_OF(RSA_PRIME_INFO) *prime_infos;
    /* If a PSS only key this contains the parameter restrictions */
    RSA_PSS_PARAMS *pss;
    /* be careful using this if the RSA structure is shared */
    CRYPTO_EX_DATA ex_data;
    CRYPTO_REF_COUNT references;
    int flags;
    /* Used to cache montgomery values */
    BN_MONT_CTX *_method_mod_n;
    BN_MONT_CTX *_method_mod_p;
    BN_MONT_CTX *_method_mod_q;
    /*
     * all BIGNUM values are actually in the following data, if it is not
     * NULL
     */
    char *bignum_data;
    BN_BLINDING *blinding;
    BN_BLINDING *mt_blinding;
    CRYPTO_RWLOCK *lock;
};
```

### 4.2. `RSA_sign`源码解析

```cpp
// crypto/rsa/rsa_sign.c

int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
             unsigned char *sigret, unsigned int *siglen, RSA *rsa)
{
    int encrypt_len, encoded_len = 0, ret = 0;
    unsigned char *tmps = NULL;
    const unsigned char *encoded = NULL;

    // 这里判断是否存在自定义sign函数，一般由引擎指定
    if (rsa->meth->rsa_sign) {
        return rsa->meth->rsa_sign(type, m, m_len, sigret, siglen, rsa);
    }

    // 1. 先进行编码，根据type做不同的编码，也就是摘要算法
    /* Compute the encoded digest. */
    if (type == NID_md5_sha1) {
        // 这里看起来像是md5_sha1算法需要外部自己算好，传进来的只能是36位
        /*
         * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and
         * earlier. It has no DigestInfo wrapper but otherwise is
         * RSASSA-PKCS1-v1_5.
         */
        if (m_len != SSL_SIG_LENGTH) {
            RSAerr(RSA_F_RSA_SIGN, RSA_R_INVALID_MESSAGE_LENGTH);
            return 0;
        }
        encoded_len = SSL_SIG_LENGTH;
        encoded = m;
    } else {
        // 这一步会根据不用的type进行不同的编码，具体type定义在 openssl/obj_mac.h
        if (!encode_pkcs1(&tmps, &encoded_len, type, m, m_len))
            goto err;
        encoded = tmps;
    }

    // 判断了编码后的数据必须小于rsa支持的加密长度减去RSA_PKCS1_PADDING会占用的最小长度
    if (encoded_len > RSA_size(rsa) - RSA_PKCS1_PADDING_SIZE) {
        RSAerr(RSA_F_RSA_SIGN, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
        goto err;
    }

    // 2. 真正进行加密，使用的是编码后的数据进行加密
    // 默认使用RSA_PKCS1_PADDING算法进行添加padding，会自动添加padding
    // 注意加密使用的是私钥，所以rsa里面只需要存放私钥就可以了
    encrypt_len = RSA_private_encrypt(encoded_len, encoded, sigret, rsa,
                                      RSA_PKCS1_PADDING);
    if (encrypt_len <= 0)
        goto err;

    *siglen = encrypt_len;
    ret = 1;

err:
    OPENSSL_clear_free(tmps, (size_t)encoded_len);
    return ret;
}
```

### 4.3. `RSA_verify`源码解析

```cpp
// crypto/rsa/rsa_sign.c

/*
 * int_rsa_verify verifies an RSA signature in |sigbuf| using |rsa|. It may be
 * called in two modes. If |rm| is NULL, it verifies the signature for digest
 * |m|. Otherwise, it recovers the digest from the signature, writing the digest
 * to |rm| and the length to |*prm_len|. |type| is the NID of the digest
 * algorithm to use. It returns one on successful verification and zero
 * otherwise.
 */
int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
                   unsigned char *rm, size_t *prm_len,
                   const unsigned char *sigbuf, size_t siglen, RSA *rsa)
{
    int decrypt_len, ret = 0, encoded_len = 0;
    unsigned char *decrypt_buf = NULL, *encoded = NULL;

    // 判断siglen是否符合RSA中定义的可解密的长度
    if (siglen != (size_t)RSA_size(rsa)) {
        RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_WRONG_SIGNATURE_LENGTH);
        return 0;
    }

    /* Recover the encoded digest. */
    decrypt_buf = OPENSSL_malloc(siglen);
    if (decrypt_buf == NULL) {
        RSAerr(RSA_F_INT_RSA_VERIFY, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    // 1. 第一步就是直接使用公钥进行解密，同样默认使用RSA_PKCS1_PADDING
    // verify需要的是公钥，所以rsa中只需要存放公钥就可以了
    // 返回的数据已经去除了padding
    decrypt_len = RSA_public_decrypt((int)siglen, sigbuf, decrypt_buf, rsa,
                                     RSA_PKCS1_PADDING);
    if (decrypt_len <= 0)
        goto err;

    if (type == NID_md5_sha1) {
        // md5_sha1直接判断解密后的数据是否和传入的一致
        /*
         * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and
         * earlier. It has no DigestInfo wrapper but otherwise is
         * RSASSA-PKCS1-v1_5.
         */
        if (decrypt_len != SSL_SIG_LENGTH) {
            RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
            goto err;
        }

        if (rm != NULL) {
            memcpy(rm, decrypt_buf, SSL_SIG_LENGTH);
            *prm_len = SSL_SIG_LENGTH;
        } else {
            if (m_len != SSL_SIG_LENGTH) {
                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);
                goto err;
            }

            if (memcmp(decrypt_buf, m, SSL_SIG_LENGTH) != 0) {
                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
                goto err;
            }
        }
    } else if (type == NID_mdc2 && decrypt_len == 2 + 16
               && decrypt_buf[0] == 0x04 && decrypt_buf[1] == 0x10) {
        // mdc2算法需要解密后的数据前两字节固定，解密后长度必须是18，然后判断原文和解密后的第3字节开始的16字节是否对应
        /*
         * Oddball MDC2 case: signature can be OCTET STRING. check for correct
         * tag and length octets.
         */
        if (rm != NULL) {
            memcpy(rm, decrypt_buf + 2, 16);
            *prm_len = 16;
        } else {
            if (m_len != 16) {
                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);
                goto err;
            }

            if (memcmp(m, decrypt_buf + 2, 16) != 0) {
                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
                goto err;
            }
        }
    } else {
        /*
         * If recovering the digest, extract a digest-sized output from the end
         * of |decrypt_buf| for |encode_pkcs1|, then compare the decryption
         * output as in a standard verification.
         */
        if (rm != NULL) {
            const EVP_MD *md = EVP_get_digestbynid(type);
            if (md == NULL) {
                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_UNKNOWN_ALGORITHM_TYPE);
                goto err;
            }

            m_len = EVP_MD_size(md);
            if (m_len > (size_t)decrypt_len) {
                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);
                goto err;
            }
            m = decrypt_buf + decrypt_len - m_len;
        }

        /* Construct the encoded digest and ensure it matches. */
        // 这里就先对原文进行了编码，和RSA_sign逻辑一样
        if (!encode_pkcs1(&encoded, &encoded_len, type, m, m_len))
            goto err;

        // 然后判断编码后的和解密出来的是否一致
        if (encoded_len != decrypt_len
            || memcmp(encoded, decrypt_buf, encoded_len) != 0) {
            RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
            goto err;
        }

        /* Output the recovered digest. */
        if (rm != NULL) {
            memcpy(rm, m, m_len);
            *prm_len = m_len;
        }
    }

    ret = 1;

err:
    OPENSSL_clear_free(encoded, (size_t)encoded_len);
    OPENSSL_clear_free(decrypt_buf, siglen);
    return ret;
}

int RSA_verify(int type, const unsigned char *m, unsigned int m_len,
               const unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
{
    // 判断是否有自定义校验函数，没有就用默认的，一般引擎会指定
    if (rsa->meth->rsa_verify) {
        return rsa->meth->rsa_verify(type, m, m_len, sigbuf, siglen, rsa);
    }

    return int_rsa_verify(type, m, m_len, NULL, NULL, sigbuf, siglen, rsa);
}
```

# 四、握手流程分析

## 1. 重协商流程

<img src="2022-01-24-01.png">

- 199.200.2.170是服务端ip

## 2. 握手流程源码分析

- 服务端握手流程主要看`statem_srvr.c`，客户端看`statem_clnt.c`

### 2.1. 服务端流程

## 2. 双向认证流程

```plantuml
@startuml ssl握手的双向认证

title ssl握手的双向认证

participant client
participant server

== ssl握手阶段 ==

client->server: Client Hello
server->client: Ack
note over client
发起Client Hello后
需要等待服务端的Server Hello Done
end note

note over server
收到握手请求后，
构造服务端的证书返回
end note
server->client: Server Hello, Certificate, Server Key Exchange
note over client
校验服务端的证书是否授信
end note
note over server
根据配置发现需要双向认证
要求客户端发送证书来验证
end note
server->client: Certificate Request, Server Hello Done
server<-client: Ack

note over client
收到Server Hello Done
发现服务端要求提交证书
构造证书请求 Certificate，证书内包含了公钥
构造证书签名请求 Certificate Verify，使用证书的私钥对证书做签名
end note
client->server: Certificate, Client Key Exchange, Certificate Verify, Change Cipher Spec, Encrypted Handshake Message
note over server
收到客户端证书后，解出来公钥
使用公钥解密签名信息，确认签名无误
确认证书对应的CA在服务端有注册，返回成功
end note
server->client: Ack

== 开始ssl数据传输 ==

@enduml
```

# 小技巧和踩坑记

## 1. 使用openssl命令模拟https请求

- https就是在ssl握手的基础上，发送http请求
- http请求的原生格式如下

```
POST /xxx/aaa/ddd HTTP/1.1
Host: 172.22.230.48
Content-Type: application/json
Content-Length: 125


{"appName":"test","containerName": "1","model":"aa","certSN":"12345","path":"c:\\asdf","username":"asdf","issuer":"asdf"}
```

- 当openssl连接上服务端的端口后，将上述文本复制到命令行，回车即可发送请求
- 注: content-length是要求和正文内容长度一致，需要注意换行所占字节数

## 2. 让浏览器信任自己颁发的证书

### 1) windows

- 只需要将CA导入到ie的受信任的根证书颁发机构就好了

### 2) linux

#### archlinux

[信任CA证书](/blogs/2021-04-02-archlinux/#4-信任CA证书)

#### ubuntu

[信任CA证书](/blogs/2018-07-27-ubuntuStudy/#2-信任CA证书)

### 其他问题

#### (1) <font color="red">自己颁发的证书，chrome导入了ca还是不授信</font>

- 新版chrome加了一个安全选项，需要存在SAN（Subject Alternative Name）字段才可以授信
- 操作具体见 [生成带拓展字段的证书](#3-生成带拓展字段的证书)
- 格式类似下面

```shell
...
        X509v3 extensions:
            ...
            X509v3 Subject Alternative Name:
                DNS:www.abcdtest.com
...
```

- DNS字段需要和访问的域名对应才行
