---
title: 30天自制操作系统笔记
date: 2019-04-25 15:58:18
tags:
categories: [Knowledge, Study]
---

# 关键词解释

- 启动区: (bootsector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。
- IPL: （initial program loader）启动程序加载器。启动区只有区区512字节，实际的操作系统不像hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区称为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。如果有人正义感特别强，觉得“这是撒谎造假，万万不能容忍！＂，那也可以改成其他的名字。但是必须起一个8字节的名字，如果名字长度不到8字节的话，常要在最后补上空格。

# 第1天

1. 环境windows
2. 二进制编辑器 notepad++安装hexeditor插件
3. 汇编编辑器 vscode安装x86 and x86_64 Assembly
4. 编译需要使用光盘中的nask编译器

## 1.1. vmware启动img

- 创建系统选择other/other
- 创建好需要添加硬件，选择软盘，然后使用文件，选择img即可启动

# 第2天

## 2.1. 标准FAT12软盘格式

```assembly
; 以下的记述用于标准FAT12格式的软盘
    JMP     entry
    DB      0x90
    DB      "HELLOIPL"      ; 启动区的名称可以是任意的字符串
    DW      512             ; 每个扇区（sector）的大小（必须为512字节）
    DB      1               ; 簇（cluster）的大小（必须为1个扇区）
    DW      1               ; FAT的起始位置（一般从第一个扇区开始）
    DB      2               ; FAT的个数（必须为2）
    DW      224             ; 根目录的大小（一般设成224项）
    DW      2880            ; 该磁盘的大小（必须是2880扇区）
    DB      0xf0            ; 磁盘的种类
    DW      9               ; FAT的长度（必须是9扇区）
    DW      18              ; 1个磁道（track）有几个扇区（必须是18）
    DW      2               ; 磁头数（必须是2）
    DD      0               ; 不使用分区，必须是0
    DD      2880            ; 重写一次磁盘大小
    DB      0, 0, 0x29      ; 意义不明，固定
    DD      0xffffffff      ; （可能是）卷标号码
    DB      "HELLO-OS   "   ; 磁盘的名称（11字节）
    DB      "FAT12   "      ; 磁盘格式名称（8字节）
    RESB    18              ; 先空出18字节
```

## 2.2. 汇编代表性寄存器介绍

### 16位寄存器

```shell
AX ---- accumulator         累加寄存器
CX ---- counter             计数寄存器
DX ---- data                数据寄存器
BX ---- base                基址寄存器
SP ---- stack pointer       栈指针寄存器
BP ---- base pointer        基址指针寄存器
SI ---- source index        源变址寄存器
DI ---- destination index   目的变址寄存器
```

### 8位寄存器

8位寄存器为16位寄存器的扩展，AL和AH一起代表AX，并不是单独的寄存器

```shell
AL ---- accumulator         累加寄存器低位
CL ---- counter             计数寄存器低位
DL ---- data                数据寄存器低位
BL ---- base                基址寄存器低位
AH ---- accumulator         累加寄存器高位
CH ---- counter             计数寄存器高位
DH ---- data                数据寄存器高位
BH ---- base                基址寄存器高位
```

### 32位寄存器

- 32位系统中使用的32位寄存器，低16位和上述16位相同，高16位没有寄存器名字
- 32位寄存器加`E`代表，如`EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI`

### 段寄存器，16位

```shell
ES ---- extra segment       附加段寄存器
CS ---- code segment        代码段寄存器
SS ---- stack segment       栈段寄存器
DS ---- data segment        数据段寄存器
FS ---- segment part 2      没有名称
GS ---- segment part 3      没有名称
```

## 2.3. CPU和内存

- CPU寄存器很少，32位也只有44个字节的空间，所以需要内存当**外部储存器**
- 内存和CPU使用管脚连接，速度虽然光速，但是比起来内部寄存器还是慢很多
- 程序代码储存在内存中，一条一条读取出来进行运行
- 启动区内容的装载地址为`0x00007c00 -- 0x00007dff`，所以ORG指令选择此处为起始地址，也仅有512字节

# 第3天

## 3.1. 软盘构成

<img src = "2019_06_14_01.bmp" width = 60%>

- 一面80个柱面
- 磁盘有两面
- 每个柱面18个扇区
- 一个扇区512字节
- 一共80 \* 2 \* 18 \* 512 = 1474560 Byte = 1440 KB
- `C0-H0-S1`代表柱面0，磁头0，扇区1
- 扇区从1开始计数，柱面从0开始计数

### (1) 软盘保存文件

- 文件名写在`0x0002600`的地方
- 文件内容写在`0x004200`的地方
- 编译生成的第三阶段启动程序代码在0x004200位置

## 3.2. 内存寻址

- `ES : BX`代表内存寻址的地址，其中BX为0-3位，ES为4-位。如`ES=0x0820，BX=0，代表0x8200地址`。总内存为12位，1M左右。
- 内存`0x7c00-0x7dff`为启动区使用，`0x7e00-0x9fbff`没有什么用，留给操作系统开发使用
- 内存寻址需要指定段寄存器DS，不然就会加上其16倍的数据，所以一般DS = 0

## 3.3. 汇编和C语言链接

- 使用汇编可以编译出`.obj`（`.o`）文件，这个文件和C文件编译出来的是一个效果
- 可以使用`objdump`来查看c语言生成的汇编指令代码
- 既然都是原生汇编，按照c语言生成的汇编格式来写汇编，同样可以链接到c语言中

```assembly
; naskfunc
; TAB=4

[FORMAT "WCOFF"]    ; 制作目标文件的模式
[BITS 32]						; 制作32位的机器语言

; 制作目标文件的信息
[FILE "naskfunc.nas"]   ; 源文件名称
		GLOBAL	_io_hlt     ; 函数名

; 函数的实现
[SECTION .text]		; text段，储存程序代码
_io_hlt:	; void io_hlt(void);
		HLT
		RET
```

## 3.4. BIOS介绍

- BIOS是使用16位机器语言，32位模式不能调用BIOS函数
- VRAM（video RAM）在当前画面模式下是`0xa0000 ~ 0xaffff`，这个是在BIOS文档中`INT 0x10`说明最后写着

## 3.5. cpu介绍

- 为什么写程序使用`i486p`，这个是cpu指令集
- i486p是给486cpu使用，但是如果只是用16位寄存器，也可以8086用
- intel系列cpu家谱

```
8086->80186->286->386->486->Pentium->PentiumPro->PentiumII->PentiumIII->Pentium4->...
```

- 到286为止是16位cpu，386之后为32位

# 第4天

## 1. 图形化界面

参考[linux-kernel启动过程](/blogs/2021-03-22-linux-kernel)

## 2. 调色板

- 调色板是显卡的一个模块，由于颜色只有8位，也就是256色，但是正常RGB有24位
- 所以我们可以给显卡设置256种颜色，0-255分别表示一种颜色
- 在用的时候直接设置对应内存为一个号码，显卡就会直接将对应位置显示成对应的颜色
- 但是cpu中断和调色板的io存取需要使用汇编来实现，c语言无法实现

**设置调色板**

- 先屏蔽中断
- 将想要设置的号码（0-255）写入到`0x03c8`
- 然后按照RGB的顺序写入`0x03c9`，想要继续设定，就直接继续写就行了
- 想要读出来对应号码的RGB，将号码写入到`0x03c7`，再从`0x03c9`读取3次。同理继续读就是下一个号码
- 最后恢复中断位

```cpp
void set_palette(int start, int end, unsigned char *rgb) {
    int i, eflags;
    eflags = io_load_eflags(); /* 记录终端许可标志的值 */
    io_cli();                  /* 将许可标志置0，禁止中断 */
    io_out8(0x03c8, start);
    for (i = start; i <= end; i++) {
        io_out8(0x03c9, rgb[0] / 4);    // R
        io_out8(0x03c9, rgb[1] / 4);    // G
        io_out8(0x03c9, rgb[2] / 4);    // B
        rgb += 3;
    }
    io_store_eflags(eflags); /* 恢复许可标志 */
    return;
}
```


