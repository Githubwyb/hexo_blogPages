---
title: 架构师相关知识
date: 2022-12-28 14:48:36
tags: [后台开发]
categories: [Program, Web]
---

# 名词解释

- DFX（Design For X）: 面向产品生命周期设计以及面向来自客户对产品的要求的设计，X可以指产品生命周期内的某一个环节或特性
- RAMS: 广义可靠性
    - Reliability － 可靠性
    - Availability － 可用性
    - Maintainability － 可维护性
    - Safety － 安全性（人身安全）
- 可维护性: 产品在规定的条件下和规定的时间内，按规定的程序和方法进行维护时，保持或恢复到规定状态的能力。
- 可用性: 是产品在任意一个随机时刻处于可用状态的能力。可用性＝可用时间/（可用时间＋不可用时间）

# 一、大型架构演进

## 1. 系统处理能力提升途径

|          | 垂直伸缩                                                 | 水平伸缩                                                                 |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------------------ |
| 伸缩途径 | 单机性能提升                                             | 增加机器组建集群                                                         |
| 行业     | 传统行业，如银行                                         | 互联网行业                                                               |
| 成本     | 增加处理能力到某个程度后，会需要更多的钱来进行更高的提升 | 增加服务器的成本为线性的                                                 |
| 极限     | 物理处理存在极限<br>操作系统或应用程序处理存在极限       | 增加服务器就可以提升性能<br>应用程序和系统在不同服务器运行，不会达到极限 |

## 2. 架构演进

| 用户数 | 方案                                                | 解决瓶颈                             | 当前性能瓶颈                                             |
| ------ | --------------------------------------------------- | ------------------------------------ | -------------------------------------------------------- |
| 少量   | 单机系统处理                                        |                                      | 数据在业务层处理复杂度                                   |
| 万级   | 使用数据库处理数据，业务读取数据库                  | 应用处理瓶颈                         | 单机数据库读写瓶颈以及应用的cpu处理瓶颈                  |
| 十万级 | 需要增加缓存改善，应用服务分布式集群                | 单机cpu处理瓶颈                      | 数据库io瓶颈                                             |
| 百万级 | 使用cdn和反向代理进行加速响应<br>数据库进行读写分离 | 数据库处理速度，减少静态资源处理消耗 | 文件系统和数据库处理瓶颈                                 |
| 千万级 | 分布式文件系统，分布式数据库系统                    | 文件系统和数据库处理瓶颈             | 数据量大了之后，硬件性能、数据库、处理数据的能力都是瓶颈 |
| 亿级   | 使用搜索引擎、NoSQL、消息队列与分布式服务           | 业务增加的复杂度                     |                                                          |

- 数据库应用分离
- [缓存](/blogs/2022-11-27-cache.md)改进性能
- 应用服务集群，使用负载均衡调度到不同的应用服务器
- 数据库读写分离
- 反向代理和CDN加速响应
- 分布式文件系统和分布式数据库系统
- 使用消息队列与分布式服务

# 二、数据库

## 1. 数据库读写分离

- 读操作和写操作对应不同场景，写操作更耗费性能
- 将写操作写入主服务器，通过复制的方式到读数据库，加快读数据的响应速度

## 2. mysql

### 2.1. 备份方案

参考 [9 Best MySQL Backup Tools](https://www.pcwdld.com/best-mysql-backup-tools#wbounce-modal)

- 物理备份：二进制文件拷贝，需要重启mysql但是耗时很短，不锁表，占用空间较大，percona开源
  - 首次物理备份后可以通过增量拉取变更数据（基于LSN计算偏移量）
  - 备份需要读取mysql的binlog，只能在对应机器执行，不能ip+端口远程执行
- 逻辑备份：基于sql脚本，占用空间小，但是会锁表，不需要重启mysql，官方自带

# 三、CDN和反向代理

## 1. 使用场景

- 一般对于静态资源放到cdn服务器上，不会到应用处理服务器上

# 四、分布式消息队列

# 五、本地集群和分布式集群

## 1. 本地集群

- 本地集群是指由多台计算机组成的集群，这些计算机通常位于同一地理位置，通过局域网或高速网络连接在一起。本地集群通常用于处理大量数据或执行计算密集型任务，例如科学计算、数据分析和机器学习等
- 在互联网场景下，本地集群可以认为是一台高性能设备

### 1.1. 本地集群的模式

- 主从集群是由一个主节点和多个从节点组成的集群，主节点负责处理所有的写操作，从节点则负责复制主节点的数据并处理读操作。主节点和从节点之间通过数据同步机制保持数据的一致性。当主节点发生故障时，从节点中的一个会被选举为新的主节点，继续处理写操作。
- 主备集群是由一个主节点和一个备节点组成的集群，主节点负责处理所有的写操作，备节点则负责复制主节点的数据。当主节点发生故障时，备节点会接管主节点的工作，成为新的主节点。与主从集群不同的是，主备集群只有一个备节点，因此在备节点接管主节点工作的过程中，可能会出现一段时间的数据不一致。

### 1.2. 主从集群

所有节点参与分发，主节点关注写操作，其他节点均只有读操作，写操作从主节点复制过来

#### 1) 集群分发模式

##### NAT 网络层处理

- 主节点将用户请求的数据包的目的地址修改为从节点，转发给从节点
- 从节点处理完后，返还给主节点，主节点再将源ip改为集群ip发出去
- 三层代理

##### DR 数据链路层处理

- 主节点将用户请求的数据包的目的mac地址修改为从节点，发给从节点
- 从节点处理后，将数据包以集群ip为源地址直接发出去
- 二层代理

### 1.3. 主备集群

## 2. 分布式集群

- 分布式集群是指由多台计算机组成的集群，这些计算机通常位于不同的地理位置，通过互联网或其他网络连接在一起。分布式集群通常用于处理大规模的数据和任务，例如大规模网站、分布式数据库和分布式文件系统等
- 互联网场景下，分布式集群是多个不同地理位置的设备共同提供服务

# 六、性能优化

## 1. 限流

### 1.1. 并发连接数

- 同一时间的连接总数上限
- 可能会因为某些请求的处理时间较长而导致限流

#### 1) 限流报错排查

- 一般看处理日志，是否某些请求的处理卡住超时

### 1.2. 新建连接数

- 每秒新建总数上限

#### 1) 限流报错排查

- 这种一般是下发了事件后，同一时间客户端的请求数量过大，一般做客户端请求离散化或服务端下发事件离散化处理即可

# 七、可靠性设计

## 1. 基本概念

- 可靠性工程（Reliability Engineering）: 是在产品寿命周期全过程（论证、方案、工程研制、生产和使用）中同产品故障作斗争的一门学科

### 1.1. 可靠性: 产品在规定的条件下、规定的时间内完成规定的功能的能力，即业界所说的三规。是产品的一种固有属性

#### 1) 规定的条件：产品的运行环境

- 环境条件：温度，湿度，压力，振动，冲击，电磁场，电磁辐射等等
- 工作条件：工作应力，系统负载，业务模型，人员操作等等

#### 2) 规定的时间：产品的生命周期

- 工作时间：时长（小时）、频次（次数）、距离（公里），例如交换机寿命20年，手机寿命5年，手机划盖工作寿命6万次，汽车寿命30万公里
- 非工作时间：待机状态，储存状态等

#### 3) 规定的功能：产品的技术性指标

- 指产品标准或产品技术条件中所规定的各项技术性能（技术指标）

### 1.2. 故障（Fault）：系统内的对象实体相对正常状态的偏离（站在这个对象的外部来看）的一种静态状态。例如进程挂死，硬盘坏道，CPU降频，网络丢包，文件系统只读，配置文件丢失等等

- 偏离的表现形式称之为故障模式 =  故障对象（主语）+ 故障表现（谓语）
    - 故障对象：保证系统运行以及提供业务能力的物理（硬盘、网卡等等）或者逻辑实体（进程、文件、数据等），可以是一个单一实体，也可以是多个单一实体组成的综合实体（主机、集群、站点等），其本质是系统的组成成分，类似于一座房子的墙面，房梁、房檐、砖头、瓦片；也类似于一个人的四肢、眼睛、耳朵、嘴巴等
    - 故障表现：偏离于正常状态的表达，一般是动词、形容词来表示，比如只读、退出、掉电、卡慢、崩溃、坏道、高温、泄漏、过载、损坏、丢失、抢占、重启、失败、空间满等等
    - 系统是由软件和硬件构成的，所以系统的故障对象就是软件和硬件，其中硬件包含主机（主机本身如主板、机箱等；以及主机上的硬件部件如硬盘、网卡、CPU、电源、风扇、内存、PCIE接口等等）以及网络设备（用于主机之间的连接，例如交换机、路由器、光纤网线、网卡/光模块等），软件包含操作系统（内核、驱动、系统服务等）、系统业务软件（包含进程、服务、容器、虚拟机、数据、文件、开源中间件等等）
- 故障被激活（Active）的时候会产生错误（Error），未被激活的故障就是休眠的/静默的（Dormant）
- 故障来源：
    - 对象实体内部自然产生的：例如软件缺陷，硬件的自然损坏等。也叫作内源性故障
    - 对象实体外部交互产生的：例如配置类故障（配置项不正确），误操作类故障（误删文件）、交互类故障等、也叫作外源性故障

### 1.3. 错误（Error）：是故障被激活后的一种动态状态，也是会直接导致业务失效的某种状态（State）。典型的错误如消息发送超时（网络丢包被激活导致的），请求无响应（对端进程挂死被激活导致的），配置文件读失败（配置文件丢失被激活导致的），硬盘写超时（硬盘坏道被激活导致的），硬盘读写慢（硬盘坏道被激活导致的）等等

- 激活：业务操作路径经过了某个存在故障的对象实体，从而导致该对象实体的某个故障被激活（也就是说故障只有被激活才会对系统产生影响，静默故障是无害的）
- 错误检测：当某个错误信息或者错误信号（Error message or Error signal）未被感知到，该错误就叫做静默错误（Latent Error），例如未感知到超时等
- 错误未被检测或者检测到而未有容错处理的话，就会产生业务失效（中断、性能下降等）
- 错误模式：类似于故障模式，区别是错误对象通常是业务操作而不是系统内部组件，错误表现和故障表现基本上是一样的

### 1.4. 失效（Failure）：系统当前的业务偏离正常业务（Correct Service ）的事件

- 偏离的表现：未按照规格要求实现或者规格要求本身不完整，通常称之为业务中断（Service Outage）
- 偏离正常业务的表现形式称之为失效模式（Failure Mode） = 失效对象  +  失效表现
    - 失效对象：与故障对象不同的是，失效是基于外部客户业务的角度进行描述的，因此失效对象主要为客户的业务类型/模型或者抽象表达，所以描述为业务（数据面-用户业务）、数据（数据面-用户数据）、控制台（管控面）、扩容（运维面）、升级（运维面）、更换（运维面）等等诸如此类
    - 失效表现：相对于故障表现而言，会更加聚焦一些，一般也是动词、形容词来表达，主要有中断，卡慢，超时，丢失/错误，失败等
- 失效的行为规律：
    - 持续性失效：一直失效直到人为恢复
    - 间歇性/周期性失效：周期性或者无规律隔段时间出现一次然后自我恢复
    - 偶然性失效：偶然出现一次然后自我恢复
- 失效对客户业务不同的影响程度的等级叫做失效严重程度（ Failure Severities ），也叫失效严酷度
    - 失效对象对于客户而言就有重要性之分（不同的业务类型有着不同的重要性，比如说数据面业务重要性要大于管控面业务），同时对象本身还隐含着范围的概念（主要是指影响的用户数量，比如是影响了所有用户，还是影响了少部分用户，影响的用户数据范围等）
    - 失效表现的角度来看也会有所区分，从两个维度来看，一是失效表现本身对客户的影响大小（比如数据丢失就是业务中断要影响大，中断要比卡慢影响大等等），二是失效表现的关键特征（包括持续时间例如时间越长对客户影响越大、出现次数例如次数越多则对客户影响越大）
    - 在其他条件同等下，业务越重要、影响用户越多、影响越深、持续时间越长、发生次数越多则严重程度越高
- 可以是部分业务失效也可以是全部业务失效。部分失效也叫作降级工作状态，表现为业务降速，业务受限，应急状态等
- 失效是在系统的边界处体现出来的非正常的输出表现

## 2. 度量体系

### 2.1. 业务零中断

### 2.2. 数据零丢失

### 2.3. 抗百倍过载

### 2.4. 故障秒级检测与自愈

### 2.5. 事故分钟级恢复

### 2.6. 测试指标

- 故障自动检测率
- 故障自动恢复率
- 故障自动检测时长、故障自动恢复时长
- 故障人工恢复时长
- 过载保护评估: 过载倍数下保障正常负载的成功率，如5倍负载保障1倍负载的98%可用

## 3. 系统可靠性设计

### 3.1. 故障预防

#### 1) 人因差错

- 防用户出错：例如硬件防用户插反，软件上阻止用户的错误操作（系统不支持的操作），删除操作光标默认在取消键
- 防出错影响：例如硬盘插错服务器了，IP地址冲突了
- 改错误结果：例如用户配置错了，能够修改正确

#### 2) 高危操作

- 风险预警：风险说明，用户确认，必要时输入管理员密码

#### 3) 失效检查：导致后续失败的条件，尽早检查，在入口检查

- 兼容检查：对于不兼容的软件，硬件，运行环境，给用户提示，不允许下一步操作
- 失败检查：例如升级前检查，导致升级失败的不让升级；文件复制前的存储空间检查

### 3.2. 故障检测&定位

#### 1) 故障检测：将系统内的故障通过业务程序本身或者公共程序感知出来

- 业务路径上的故障（Error）：业务流程直接感知的会导致业务出现失败的故障，例如消息超时无响应，空间不足，读写错误，发送失败等
- 非业务路径的故障（Fault）：业务流程不可直接感知的，但是会潜在的或者直接的导致业务失败的故障，例如进程挂死，网络断开，资源过载、电源损坏，SSD寿命到期等等

#### 2) 故障定位：故障发生的位置

- 软件故障：定位到可管理单元（FMU），软件模块（进程，服务，文件等等）
- 硬件故障：定位到可更换单元（FRU），硬盘，网口，光模块，内存（物理位置信息）

### 3.3. 故障隔离：在软件模块，硬件部件、网络冗余部署的情况下，隔离机制才有效。

- 硬件部件：硬件出现整体或者局部的损坏（变慢等），特别是局部的损坏（比如内存有局部损坏，将局部区域隔离，该内存条可以继续使用）价值更大，将该硬件整体或者局部区域（硬件还可以使用）不再使用
- 软件模块：软件模块出现整体无法运行或者频繁启停或者运行缓慢，将该软件模块停止运行并从软件模块集群中分离出来
- 网络连接：网络连接出现中断，闪断、丢包、延迟等现象，将该网络连接断开或者让软件不使用该网络连接

### 3.4. 故障上报：需要用户介入处理的故障才要上报告警

- 故障预警：当前还未产生影响，但是如果不处理，后续可能产生影响。比如资源过载，容量过载，寿命到期之类的故障
- 自动容错：该故障系统有容错措施，未对用户产生业务影响，但是系统无法自动修复该故障本身，需要人工介入恢复，比如进程无法启动，网络断开，硬件损坏等
- 业务失效：该故障已经对用户业务造成了影响，系统无法自动恢复该故障，比如数据损坏，主备倒换失败，主备机同时故障

### 3.5. 故障恢复&修复

#### 1)业务恢复：用户业务的恢复，包括自动和手动两种方式

- 软件模块：自动的机制如故障对象自动重启，故障对象自动切换（双机、集群等），发送方自动重试，发送方重新选择发送路径或者发送对象，备份恢复；手动的机制就是应急处理（人工介入）
- 硬件模块：自动的机制就是切换到另一个冗余部件上去，或者采用隔离技术将局部硬件故障隔离。手动的机制同软件模块

#### 2) 故障修复：故障本身的恢复，也可能会直接产生业务恢复

- 软件模块：通过备份进行恢复（文件，数据）；升级补丁等
- 硬件模块：硬件维修，硬件更换、硬件拔插

### 3.6. 冗余设计

- 冗余设计是设备故障自动恢复的条件之一
- 软件上的冗余意义不大，同样条件下切换了软件还是会出现问题
- 一般冗余是主机冗余和网络冗余

#### 1) 主机冗余

- 主机冗余一般是两台主机做主备
- 对于主机内部一般是电源、风险、系统盘做冗余，cpu、内存等不做冗余
- 主机冗余一般是考虑故障率和成本的平衡

#### 2) 网络冗余

- 一般是网口、交换机等设备的冗余

### 3.7. 故障管理

#### 1) 总体框架

- 系统可靠性服务不能耦合被管理对象
- 可靠性服务需要比被管理服务简单，否则无法保障可靠性

#### 2) 故障隔离

- 网络平面隔离
    - 物理隔离: 不同网络平面采取不同的物理接口
    - 逻辑隔离: 使用vlan进行隔离，单平面故障不影响其他平面
- 集群隔离
    - 每个集群内部故障只影响本集群的问题，不影响其他集群节点
- 业务平面隔离
    - 管理面、控制面和数据面隔离，数据面卡死不影响管理面访问
    - 逃生通道、BMC
- 数据隔离
    - 用户数据: 不同数据分布在不同硬盘、不同主机、不同站点等
    - 系统数据: 配置数据和日志数据放在不同的磁盘分区；配置数据支持备份到第三方系统；元数据和数据放在不同存储介质
- 资源隔离
    - 物理隔离: cpu和内存的物理绑定，硬盘分区
    - 逻辑隔离: QoS控制机制，cgroup机制，目录配额

#### 3) 过载保护

##### (1) 熔断

- 定义目标服务调用慢或超时的熔断阈值，超过阈值定义熔断机制，隔离服务或者其他跳过机制
- 低于阈值后恢复调用
- 熔断是防止雪崩，存在关闭、半熔断、开启三种状态

##### (2) 限流

- 限流是在已有的条件下，最大限度发挥系统效能
- 限流阈值需要基于现有业务和系统进行确定
    - 量化限流阈值
    - 确定限流策略、算法
    - 被限制流量的处理
- 限流算法业界推荐【两窗两桶】：固定窗口、滑动窗口、漏桶、令牌桶
- 实现原则
    - 对于进程、服务消耗的资源，需要有约束机制，避免异常超额消耗和超长时间占用
    - 要实时监控各种资源的占用情况，在达到即将饱和之前，对接入业务量进行控制
    - 发生过载时建议考虑业务/客户优先级，保证高优先级业务/客户优先获得资源
    - 控制要尽早，在源头控制，在第一个能识别流量的模块开始控制
    - 如果一个业务有多个消息，只要第一个消息进入系统了，后面的消息不要被流控掉

# 八、数据密集型应用系统设计

参考书本《数据密集型应用系统设计》

## 第一部分 数据系统基础

### 1. 可靠、可拓展与可维护的应用系统

#### 1.1. 可靠性

- 用户期望的功能实现
- 容忍用户错误或不正确的使用方法
- 性能可以应对的典型场景、压力和数据量
- 系统可以防止未经授权的访问和滥用

#### 1.2. 可扩展性

**负载描述**

- qps（queries Per Second）

**性能描述**

- 百分位数：类似于中位数，不过是按照百分比计算的中位数
- 关注的百分位数一般有95%、99%、99.9%

#### 1.3. 可维护性

**运营**

- 监视系统健康状况，出现异常快速恢复
- 追踪问题原因，如系统故障和性能下降
- 保持软件和平台到最新状态，如安全补丁
- 避免执行破坏性操作
- 预测未来可能的问题，如容量不足
- 建立用于部署、配置管理等实践规范和工具包
- 执行复杂的维护任务，如迁移
- 配置更改，维护系统安全稳定
- 指定流程规范操作行为
- 传承相关知识

**系统设计考虑点**

- 提供系统运行时行为和内部的观测性，方便监控
- 自动化标准工具集成
- 避免特定机器绑定，允许整体运行完整的同时，部分机器停机维护
- 文档和操作模式良好
- 默认配置良好
- 尝试自我修复，并允许管理员手动控制状态
- 预测可能出现的意外进行处理

**简单化**

- 后续人员好维护

**可演化**

- 应对需求改变的解决方案考虑

### 2. 数据模型与查询语言

#### 2.1. 数据库分类

**关系型**

- 数据之间存在关系，查询需要按照关系进行查询
- 一般是多对多的关系
- 如sql、网络数据库、图数据库

**文档型**

- 一对多，一个id对应很多数据，但是数据之间关系不大
- 如json、xml等

## 第二部分 分布式数据系统

## 第三部分 派生数据

# 实践场景

## 1. 百万级并发优化实战

### 1.1. 背景

- 主场景为认证、资源列表下发、环境上报、资源访问鉴权

### 1.2. 如何优化点分析

**本地集群瓶颈**

- 模拟高峰流量，分析到是cpu占用过高，然后是数据库瓶颈，然后是内存

### 1.3. 优化过程

#### 1) api级别短时效缓存

- 业务处理多个地方调用接口查询数据库，对同一个数据进行多次查询不能每一次都读io
- 对接口进行api级别缓存，业务代码可直接调用数据库接口查询，接口内部会对查询数据进行缓存

#### 2) 数据预处理

- 对于每次都需要进行复杂转换和计算的大数据，提前进行预处理储存到缓存中，每次只需要读取结果即可

#### 3) 运行时数据缓存（时间局部性）

- 对于登陆访问过程中通过不同api查询同样的数据，将数据和对应id进行缓存
- 第一个api调用查询数据库然后缓存，后续直接通过id查询即可，不需要再查询数据库

#### 4) 非核心业务降频排队

- 非核心业务可能会占用数据库并加锁，如果是io密集型，将其隔离并进行低优先级排队处理，防止阻塞核心业务

#### 5) 连接池分离

- 不同业务的redis和数据库的连接池分离，核心业务和非核心业务分离，防止非核心业务占用核心业务连接池导致无法访问

#### 6) 数据库写操作有区分按不同优先级同/异步落盘

- 使用代理服务进行sql语句插入，可以进行批量插入和数据可视化
- 仅针对非强实时性要求的数据
- 可以有日志和重试可靠性处理

#### 7) 合并api请求数据

- 当某个请求过程中，api可以复用下发数据，减少api调用次数
- 不止客户端到服务端的数据复用，服务端内部的链路也同样可以复用数据

#### 8) 高峰期分析

- 对于真实场景高峰期的cpu分析，找到是否数据库索引存在问题
- 对于需要计算类型的，提前进行预处理缓存，防止索引没命中导致的扫表

### 1.4. 优化效果

- 一个主节点带两个工作节点，40w并发15min登陆上线完成，cpu占用不超过30%

## 2. 微博场景

### 2.1. twitter推送

#### 场景

- 用户发布tweet，关注者在主页可以查看到其发布的消息，按照时间线排序
- 目标，3000w关注者5s内完成发布接收

#### 方案

**方案1**

- 使用关系型数据库，每个用户发tweet插入到全局tweet库
- 每个关注者查询全局tweet库，根据自己关注的用户进行查询，获取到按照时间线排序的结果

**方案2**

- 使用redis对每个用户维护一个时间线缓存，类似邮箱
- 发布者发布tweet后，查询关注者，将tweet插入到所有关注者的时间线缓存中

**对比**

|      | 方案1                         | 方案2                                                          |
| ---- | ----------------------------- | -------------------------------------------------------------- |
| 优点 | 实现简单，发布tweet写入少     | 读负载降低，只需要读取缓存即可                                 |
| 缺点 | 全局tweet的读负载压力与日俱增 | 实现复杂，发布tweet写入多个关注者缓存中，大V情况下写入负载很高 |

#### 结论

- twitter最后使用方案2的稳定实现，但是对于大V，使用方案1。使用混合方案可以达到很好的表现
