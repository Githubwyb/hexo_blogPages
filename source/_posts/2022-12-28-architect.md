---
title: 架构师相关知识
date: 2022-12-28 14:48:36
tags: [后台开发]
categories: [Program, Web]
---

# 一、大型架构演进

## 1. 系统处理能力提升途径

|          | 垂直伸缩                                                 | 水平伸缩                                                                 |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------------------ |
| 伸缩途径 | 单机性能提升                                             | 增加机器组建集群                                                         |
| 行业     | 传统行业，如银行                                         | 互联网行业                                                               |
| 成本     | 增加处理能力到某个程度后，会需要更多的钱来进行更高的提升 | 增加服务器的成本为线性的                                                 |
| 极限     | 物理处理存在极限<br>操作系统或应用程序处理存在极限       | 增加服务器就可以提升性能<br>应用程序和系统在不同服务器运行，不会达到极限 |

## 2. 架构演进

| 用户数 | 方案                                                | 解决瓶颈                             |
| ------ | --------------------------------------------------- | ------------------------------------ |
| 少量   | 单机系统处理                                        |                                      |
| 万级   | 使用数据库处理数据，应用读取数据库                  | 应用处理瓶颈                         |
| 十万级 | 需要增加缓存改善，应用服务分布式集群                | 单应用处理瓶颈                       |
| 百万级 | 使用cdn和反向代理进行加速响应<br>数据库进行读写分离 | 数据库处理速度，减少静态资源处理消耗 |
| 千万级 | 分布式文件系统，分布式数据库系统                    | 文件系统和数据库处理瓶颈             |
| 亿级   | 使用搜索引擎、NoSQL、消息队列与分布式服务           | 业务增加的复杂度                     |

- 数据库应用分离
- [缓存](/blogs/2022-11-27-cache.md)改进性能
- 应用服务集群，使用负载均衡调度到不同的应用服务器
- 数据库读写分离
- 反向代理和CDN加速响应
- 分布式文件系统和分布式数据库系统
- 使用消息队列与分布式服务

# 二、数据库

## 1. 数据库读写分离

- 读操作和写操作对应不同场景，写操作更耗费性能
- 将写操作写入主服务器，通过复制的方式到读数据库，加快读数据的响应速度

## 2. mysql

### 2.1. 备份方案

参考 [9 Best MySQL Backup Tools](https://www.pcwdld.com/best-mysql-backup-tools#wbounce-modal)

- 物理备份：二进制文件拷贝，需要重启mysql但是耗时很短，不锁表，占用空间较大，percona开源
  - 首次物理备份后可以通过增量拉取变更数据（基于LSN计算偏移量）
  - 备份需要读取mysql的binlog，只能在对应机器执行，不能ip+端口远程执行
- 逻辑备份：基于sql脚本，占用空间小，但是会锁表，不需要重启mysql，官方自带

# 三、CDN和反向代理

## 1. 使用场景

- 一般对于静态资源放到cdn服务器上，不会到应用处理服务器上

# 四、分布式消息队列

# 五、本地集群和分布式集群

## 1. 本地集群

- 本地集群是指由多台计算机组成的集群，这些计算机通常位于同一地理位置，通过局域网或高速网络连接在一起。本地集群通常用于处理大量数据或执行计算密集型任务，例如科学计算、数据分析和机器学习等
- 在互联网场景下，本地集群可以认为是一台高性能设备

### 1.1. 本地集群的模式

- 主从集群是由一个主节点和多个从节点组成的集群，主节点负责处理所有的写操作，从节点则负责复制主节点的数据并处理读操作。主节点和从节点之间通过数据同步机制保持数据的一致性。当主节点发生故障时，从节点中的一个会被选举为新的主节点，继续处理写操作。
- 主备集群是由一个主节点和一个备节点组成的集群，主节点负责处理所有的写操作，备节点则负责复制主节点的数据。当主节点发生故障时，备节点会接管主节点的工作，成为新的主节点。与主从集群不同的是，主备集群只有一个备节点，因此在备节点接管主节点工作的过程中，可能会出现一段时间的数据不一致。

### 1.2. 主从集群

所有节点参与分发，主节点关注写操作，其他节点均只有读操作，写操作从主节点复制过来

#### 1) 集群分发模式

##### NAT 网络层处理

- 主节点将用户请求的数据包的目的地址修改为从节点，转发给从节点
- 从节点处理完后，返还给主节点，主节点再将源ip改为集群ip发出去

##### DR 数据链路层处理

- 主节点将用户请求的数据包的目的mac地址修改为从节点，发给从节点
- 从节点处理后，将数据包以集群ip为源地址直接发出去

### 1.3. 主备集群

## 2. 分布式集群

- 分布式集群是指由多台计算机组成的集群，这些计算机通常位于不同的地理位置，通过互联网或其他网络连接在一起。分布式集群通常用于处理大规模的数据和任务，例如大规模网站、分布式数据库和分布式文件系统等
- 互联网场景下，分布式集群是多个不同地理位置的设备共同提供服务

# 六、数据密集型应用系统设计

参考书本《数据密集型应用系统设计》

## 第一部分 数据系统基础

### 1. 可靠、可拓展与可维护的应用系统

#### 1.1. 可靠性

- 用户期望的功能实现
- 容忍用户错误或不正确的使用方法
- 性能可以应对的典型场景、压力和数据量
- 系统可以防止未经授权的访问和滥用

#### 1.2. 可扩展性

**负载描述**

- qps（queries Per Second）

**性能描述**

- 百分位数：类似于中位数，不过是按照百分比计算的中位数
- 关注的百分位数一般有95%、99%、99.9%

#### 1.3. 可维护性

**运营**

- 监视系统健康状况，出现异常快速恢复
- 追踪问题原因，如系统故障和性能下降
- 保持软件和平台到最新状态，如安全补丁
- 避免执行破坏性操作
- 预测未来可能的问题，如容量不足
- 建立用于部署、配置管理等实践规范和工具包
- 执行复杂的维护任务，如迁移
- 配置更改，维护系统安全稳定
- 指定流程规范操作行为
- 传承相关知识

**系统设计考虑点**

- 提供系统运行时行为和内部的观测性，方便监控
- 自动化标准工具集成
- 避免特定机器绑定，允许整体运行完整的同时，部分机器停机维护
- 文档和操作模式良好
- 默认配置良好
- 尝试自我修复，并允许管理员手动控制状态
- 预测可能出现的意外进行处理

**简单化**

- 后续人员好维护

**可演化**

- 应对需求改变的解决方案考虑

### 2. 数据模型与查询语言

#### 2.1. 数据库分类

**关系型**

- 数据之间存在关系，查询需要按照关系进行查询
- 一般是多对多的关系
- 如sql、网络数据库、图数据库

**文档型**

- 一对多，一个id对应很多数据，但是数据之间关系不大
- 如json、xml等

## 第二部分 分布式数据系统

## 第三部分 派生数据

# 外部实践场景

## 1. 百万级并发优化实战

### 1.1. 背景

- 主场景为认证、资源列表下发、环境上报、资源访问鉴权

### 1.2. 如何优化点分析

**本地集群瓶颈**

- 模拟高峰流量，分析到是cpu占用过高，然后是数据库瓶颈，然后是内存

### 1.3. 优化过程

#### 1) api级别短时效缓存

- 业务处理多个地方调用接口查询数据库，对同一个数据进行多次查询不能每一次都读io
- 对接口进行api级别缓存，业务代码可直接调用数据库接口查询，接口内部会对查询数据进行缓存

#### 2) 数据预处理

- 对于每次都需要进行复杂转换和计算的大数据，提前进行预处理储存到缓存中，每次只需要读取结果即可

#### 3) 运行时数据缓存（时间局部性）

- 对于登陆访问过程中通过不同api查询同样的数据，将数据和对应id进行缓存
- 第一个api调用查询数据库然后缓存，后续直接通过id查询即可，不需要再查询数据库

#### 4) 非核心业务降频排队

- 非核心业务可能会占用数据库并加锁，如果是io密集型，将其隔离并进行低优先级排队处理，防止阻塞核心业务

#### 5) 连接池分离

- 不同业务的redis和数据库的连接池分离，核心业务和非核心业务分离，防止非核心业务占用核心业务连接池导致无法访问

#### 6) 数据库写操作有区分按不同优先级同/异步落盘

- 使用代理服务进行sql语句插入，可以进行批量插入和数据可视化
- 仅针对非强实时性要求的数据
- 可以有日志和重试可靠性处理

#### 7) 合并api请求数据

- 当某个请求过程中，api可以复用下发数据，减少api调用次数
- 不止客户端到服务端的数据复用，服务端内部的链路也同样可以复用数据

#### 8) 高峰期分析

- 对于真实场景高峰期的cpu分析，找到是否数据库索引存在问题
- 对于需要计算类型的，提前进行预处理缓存，防止索引没命中导致的扫表

### 1.4. 优化效果

- 一个主节点带两个工作节点，40w并发15min登陆上线完成，cpu占用不超过30%

## 2. 微博场景

### 2.1. twitter推送

#### 场景

- 用户发布tweet，关注者在主页可以查看到其发布的消息，按照时间线排序
- 目标，3000w关注者5s内完成发布接收

#### 方案

**方案1**

- 使用关系型数据库，每个用户发tweet插入到全局tweet库
- 每个关注者查询全局tweet库，根据自己关注的用户进行查询，获取到按照时间线排序的结果

**方案2**

- 使用redis对每个用户维护一个时间线缓存，类似邮箱
- 发布者发布tweet后，查询关注者，将tweet插入到所有关注者的时间线缓存中

**对比**

|      | 方案1                         | 方案2                                                          |
| ---- | ----------------------------- | -------------------------------------------------------------- |
| 优点 | 实现简单，发布tweet写入少     | 读负载降低，只需要读取缓存即可                                 |
| 缺点 | 全局tweet的读负载压力与日俱增 | 实现复杂，发布tweet写入多个关注者缓存中，大V情况下写入负载很高 |

#### 结论

- twitter最后使用方案2的稳定实现，但是对于大V，使用方案1。使用混合方案可以达到很好的表现
