---
title: nodejs学习记录
date: 2020-03-23 11:26:47
tags:
categories: [Program, Web]
---

# 一、前言

本文为nodejs学习记录，包含一些语法和踩坑记，以及一些工具代码技巧等

环境

```shell
node v12.16.1
```

# 二、安装

## 1. node安装

- 具体下载地址访问官网下载`https://nodejs.org/zh-cn/download/`

```shell
wget xxxxxx             # 下载官网最新二进制文件包
mkdir temp              # 创建临时目录
tar -xzvf xxxxx.tar.gz -C temp  # 解压到临时目录
sudo mv temp/node_xxx /opt/node # 文件整体移动到opt目录下
sudo ln -s /opt/node/bin/node /usr/local/bin/node   # 添加软链接
sudo ln -s /opt/node/bin/npm /usr/local/bin/npm     # 添加软链接
```

## 2. npm 安装第三方包

### 2.1. 安装

```shell
# -g代表全局安装，不加-g安装到本地目录
# --save代表保存到package.json中
npm install -g xxx --save
```

### 2.2. 更新

```shell
# 升级npm
npm install -g npm
# 使用npm-check进行包检查更新
npm install -g npm-check
# 检查包更新，使用-g检查全局包，空格选中，回车安装
npm-check -g -u
```

# 三、语法相关(ES6)

## 1. 变量

### 1.1. let和var的区别

|            | var                              | let                |
| ---------- | -------------------------------- | ------------------ |
| 作用域     | var可以全局使用                  | let只能在代码块中  |
| 未定义使用 | 定义前使用var，会是undefined类型 | 定义前使用，会报错 |

let特性

- 同作用域下，let前所有调用变量的行为都报错，包括typeof
- let要求有大括号，不允许类似if只有一条语句不加大括号

### 1.2. const类型

- 大部分同let，有块作用域和不可声明前调用

## 2. 数组

### 2.1. 一些基础操作

```js
let arr = new Array();

/****** 删除 ******/
// 删除头部元素并返回
let head = arr.shift();

// 删除所有xxxId
let tempIndex = arr.indexOf(xxxId);
while (tempIndex !== -1) {
    arr.splice(tempIndex, 1);
    tempIndex = arr.indexOf(xxxId);
}

/****** 新增 ******/
// 插入到数组前面并返回长度
let len = arr.unshift("test");

/****** 遍历 ******/
// 不需要index，for of结构，返回只有数组的value
for (const v of obj) {
    console.log(`value: ${v}`);
}
// 使用for in结构，返回数组的index
```

### 2.2. 数组去重 Set

- Set对象类似于数组，但是元素唯一，对数组去重可以使用Set来实现

```js
let arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 1];

arr = Array.from(new Set(arr));
```

## 3. 对象

### 3.1. 一些基本操作

```js
/****** 遍历对象 ******/
let obj = {};
// 返回的是对象的key或者数组的index
for (const k in obj) {
    console.log(`key: ${k}, value: ${obj[k]}`);
}
```

## 4. 异步处理

### 4.1. Promise

#### 4.2. Promise.all

- `Promise.all()`主要用于将多个异步处理函数整合成一个异步处理，外层使用await可以等待多个异步处理函数处理完成

##### 4.2.1. 和数组结合

- 数组遍历每一个item进行处理，如果处理之间不相关，可以使用异步的方式，但是又需要等待处理完成
- 不能使用foreach，因为`Promise.all`依赖返回的Promise对象，foreach是没有返回的

```js
let testArray = [];
...
await Promise.all(testArray.map(async (item) => {
    ...
}));
```

# 四、技巧

## 1. 框架

- 服务端后台框架推荐[eggjs](https://eggjs.org/zh-cn/)

## 2. 交换元素的值

- 使用ES6的解构赋值特性

```js
let x = 1;
let y = 2;

[x, y] = [y, x];
```

## 3. jsonSchema的几种用法

### 3.1. required依赖某一项

```js
const xxxSchema = {
    name: 'xxx配置',
    type: 'object',
    required: true,
    properties: {
        test: {
            name: 'xxxxx',
            type: 'object',
            required: true,
            properties: {
                enable: {
                    name: 'enable',
                    type: 'number',
                    required: true,
                    rule: [{
                        name: 'enums',
                        enums: [0, 1],
                        message: '开启test',
                    }],
                },
                hhh: {
                    name: 'hhh',
                    type: 'string',
                    required: true,
                    // required依赖test.enable是否开启
                    dependOn: 'test.enable',
                    dependValue: [1],
                },
            },
        },
    },
};
```

### 3.2. callback自定义检查

```js
const xxxSchema = {
    name: 'xxx配置',
    type: 'object',
    required: true,
    properties: {
        enable: {
            name: 'enable',
            type: 'number',
            required: true,
            rule: [{
                name: 'enums',
                enums: [0, 1],
                message: '开启test',
            }],
        },
        test: {
            name: 'xxxxx',
            type: 'string',
            required: true,
            callback(value, params, schema) {
                try {
                    if (false) {
                        return {
                            valid: false,
                            msg: 'test错误',
                        };
                    }
                    if (value === 'aaa') {
                        throw new Error('test不能是aaa');
                    }
                    if (params.enable === 0) {
                        throw new Error('enable 0');
                    }
                } catch (err) {
                    return {
                        valid: false,
                        msg: err.message,
                    };
                }
            },
        },
    },
};
```

## 4. 暂停等待用户输入

- 这里只展示同步的，异步的自己裁代码

```js
const readline = require('readline');
const { exit } = require('process');

function readSyncByRl(tips) {
    tips = tips || '> ';

    return new Promise((resolve) => {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        rl.question(tips, (answer) => {
            rl.close();
            resolve(answer.trim());
        });
    });
}

async function main() {
    let confirmText = await readSyncByRl('是否继续？[y/N] ');
    if (confirmText !== 'Y' && confirmText !== 'y') {
        exit(1);
    }
    ...
}
```

## 5. 进度条展示

```js
'use strict';
const ProgressBar = require('progress');

// :bar 代表进度条 '-------'
// :percent 代表百分比 'xx%'
// total为计算使用的值，width是显示宽度，complete为完成的展示字符
const bar = new ProgressBar('progress: [:bar] :percent', { total: 100, width: 100, complete: '=' });
let rate = 0;
const timer = setInterval(
    () => {
        rate += 0.1;
        // update参数为0-1的值
        bar.update(rate);
        if (bar.complete) {
            console.log("\ncomplete\n");
            clearInterval(timer);
        }
    },
    500
);
```

# 五、好用的第三方`node_module`

## 1. yargs 命令行参数解析

### 1.1. 一些基本用法

```js
/* eslint-disable no-console */
'use strict';
const yargs = require('yargs');

function main() {
    // 处理解析参数
    let argv = yargs
        .usage('Usage: util.js [command] <options>')
        .strict()   // 严格模式，无法识别的参数会报错
        .alias('h', 'help')
        .command('cmd1', 'cmd1 description')
        .command('cmd2', 'cmd2 discription')
        .command('cmd3', 'cmd3 discription')
        .option('option_test_1', {
            describe: 'option_test_1 description',
            type: 'string',
        })
        .option('option_test_2', {
            describe: 'option_test_2 description',
            type: 'boolean',
            demandOption: true,
        })
        // 要求最少一个命令
        .demandCommand(1, '请输入一个命令，cmd1/cmd2/cmd3')
        .argv;
    console.log(argv);
}

main();
```

**效果**

正常
```
[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1 --option_test_1 aaa --option_test_2
{
  _: [ 'cmd1' ],
  option_test_1: 'aaa',
  option_test_2: true,
  '$0': 'util.js'
}
```

```
[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1 --option_test_1=aaa --option_test_2 aaa
{
  _: [ 'cmd1', 'aaa' ],
  option_test_1: 'aaa',
  option_test_2: true,
  '$0': 'util.js'
}
```

异常
```
[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js
Usage: util.js [command] <options>

命令：
  test.js cmd1  cmd1 description
  test.js cmd2  cmd2 discription
  test.js cmd3  cmd3 discription

选项：
  --version        显示版本号                                             [布尔]
  --option_test_1  option_test_1 description                            [字符串]
  --option_test_2  option_test_2 description                              [布尔]
  -h, --help           显示帮助信息                                       [布尔]

请输入一个命令，cmd1/cmd2/cmd3
```

```
[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1
util.js cmd1

cmd1 description

选项：
  --version        显示版本号                                             [布尔]
  --option_test_1  option_test_1 description                            [字符串]
  --option_test_2  option_test_2 description                       [布尔] [必需]
  -h, --help           显示帮助信息                                       [布尔]

缺少必须的选项：option_test_2
```

```
[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js aaa cmd1
Usage: util.js [command] <options>

命令：
  util.js cmd1  cmd1 description
  util.js cmd2  cmd2 discription
  util.js cmd3  cmd3 discription

选项：
  --version        显示版本号                                             [布尔]
  --option_test_1  option_test_1 description                            [字符串]
  --option_test_2  option_test_2 description                              [布尔]
  -h, --help           显示帮助信息                                       [布尔]

无法识别的选项：aaa
```

```
[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1 --aaa
util.js cmd1

cmd1 description

选项：
  --version        显示版本号                                             [布尔]
  --option_test_1  option_test_1 description                            [字符串]
  --option_test_2  option_test_2 description                              [布尔]
  -h, --help           显示帮助信息                                       [布尔]

无法识别的选项：aaa
```

# 踩坑记

## 1. 脚本调用promise的函数不会自动退出

```js
const readline = require('readline');
const { exit } = require('process');

function readSyncByRl(tips) {
    tips = tips || '> ';

    return new Promise((resolve) => {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        rl.question(tips, (answer) => {
            rl.close();
            resolve(answer.trim());
        });
    });
}

async function main() {
    let confirmText = await readSyncByRl('是否继续？[y/N] ');
    console.log(confirmText);
}
```

- 使用ssh执行`node xxx.js`，ssh不会退出，需要`Ctrl + c`才行
- 但是终端中执行`node xxx.js`，会自动退出
- 解决办法是，在最后加上exit();


```js
const readline = require('readline');
const { exit } = require('process');

function readSyncByRl(tips) {
    tips = tips || '> ';

    return new Promise((resolve) => {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        rl.question(tips, (answer) => {
            rl.close();
            resolve(answer.trim());
        });
    });
}

async function main() {
    let confirmText = await readSyncByRl('是否继续？[y/N] ');
    console.log(confirmText);
    exit();
}
```
