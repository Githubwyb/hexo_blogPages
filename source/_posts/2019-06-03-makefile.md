---
title: makefile文件命令
date: 2019-06-03 14:02:41
tags: [Linux]
categories: [Program, Shell]
---

# 一、makefile

## 1. 默认规则

```makefile
default :
    make run
```

- 添加默认规则，直接使用make将执行default下的命令

## 2. 文件生成

```makefile
# 文件生成规则
ipl.bin : ipl.nas Makefile
    ../z_tools/nask.exe ipl.bin ipl.lst

helloOS.img : ipl.bin Makefile
    ../z_tools/edimg.exe imgin:../z_tools/fdimg0at.tek
```

- `#`代表注释
- `ipl.bin : ipl.nas Makefile`代表需要制作`ipl.bin`文件需要`ipl.nas`和`Makefile`，如果都有，执行下面的语句
- `\`代表续行符号

## 3. 变量使用

```makefile
TOOLPATH    = ../z_tools
MAKE        = $(TOOLPATH)/make.exe -r
NASK        = $(TOOLPATH)/nask.exe
EDIMG       = $(TOOLPATH)/edimg.exe
IMGTOL      = $(TOOLPATH)/imgtol.com
COPY        = copy
DEL         = del
```

## 4. 运行规则

1. 先根据编译命令寻找规则
2. 找到规则后，匹配后面的依赖
3. 依赖匹配按照从上向下匹配，两个规则均满足，使用第一个
4. 如果依赖不满足，根据依赖继续找依赖的规则
5. 依赖满足，根据后面的命令进行编译

## 5. 内置变量符号含义

#### (1) 匹配符%和通配符*的区别

所以虽然两个符号的意思有点沾边，但是他们的工作方式时完全不一样。

**匹配符%的意思**

1. 我要找test1.o的构造规则，看看Makefile中那个规则符合。
2. 然后找到了 `%.o : %.c`
3. 来套一下来套一下：
4. `%.o` 和我要找的 `test1.o` 匹配
5. 套上了，得到%=test1。
6. 所以在后面的 `%.c` 就表示 `test1.c` 了。
7. OK进行构造

**通配符*的意思**

1. 我不知道目标的名字，系统该目录下中所有后缀为.c的文件都是我要找的。
2. 然后遍历目录的文件，看是否匹配。找出所有匹配的项目。

#### (2) 特殊符号

- `$@`: 目标的名字
- `$^`: 构造所需文件列表所有所有文件的名字
- `$<`: 构造所需文件列表的第一个文件的名字
- `$?`: 构造所需文件列表中更新过的文件
- `$*`: 匹配的目标模式中%及前面的部分，如: `dir/a.foo.b`被`a.%.b`匹配，`$*`代表`dir/a.foo`

## 6. 内置函数

### 6.1. foreach

- 用var遍历list，在text中对var进行操作

```makefile
$(foreach <var>,<list>,<text>)
```

**示例**

```makefile
C_SOURCES = $(foreach d,$(SRCDIR),$(wildcard $(d)*.c))
```

- 遍历SRCDIR，每个元素给到d中，然后执行`$(wildcard $(d)*.c)`输出

### 6.2. wildcard

- 在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”
- 它的用法是：`$(wildcard PATTERN...)`
- Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。

### 6.3. patsubst

- 替换列表中的字符串

```makefile
$(patsubst 原模式， 目标模式， 文件列表)
```

**示例**

```makefile
C_OBJS = $(patsubst %.c, $(OBJDIR)%.o, $(C_SOURCES))
```

- 取`C_SOURCES`列表文件，每一个执行`%.c`到`$(OBJDIR)%.o`的替换

## 踩坑记

- Makefile需要用tab而非空格进行缩进，否则会报`*** multiple target patterns.  Stop.`

# 二、<span id="CMakeLists">CMakeLists.txt</span>

## 1. 一些基本命令

```cmake
########## 工程定义 ##########
# cmake最小支持版本3.8
CMAKE_MINIMUM_REQUIRED(VERSION 3.8)

# 项目工程名字
PROJECT(Clion_cppStudy
    LANGUAGES C CXX
    VERSION 1.0.0.0
    DESCRIPTION "Diy c++ project"
)

########## 变量 ##########
# 设置lib库生成路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/build/lib)
# 设置bin文件生成路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/build/bin
# 编译命令导出json给其他地方使用，vim的ycm可以使用作为代码提示
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# 设置C++标准
set(CMAKE_CXX_STANDARD 11)
# 设置符号隐藏
set(CMAKE_C_VISIBILITY_PRESET hidden)
set(CMAKE_CXX_VISIBILITY_PRESET hidden)

########## 选项 ##########
# 设置选项
option(RELEASE "Build release, default is OFF" OFF)
# 根据选项指定编译类型
# 也可以使用 -DCMAKE_BUILD_TYPE:STRING=RELEASE 来指定，默认为RELEASE
# 如果文件中有SET，使用选项将无效
if(RELEASE)
   SET(CMAKE_BUILD_TYPE "RELEASE")
else(RELEASE)
   SET(CMAKE_BUILD_TYPE "DEBUG")
endif(RELEASE)

# 添加子目录
add_subdirectory(src)

# FILE生成的是绝对路径文件
# GLOB和GLOB_RECUSE语法一样，但是一个会对子目录匹配，一个不会匹配子目录
# 两种方式都无法检测文件变化，如果文件变化需要重新config工程
# 匹配app和utils一级目录的c开头后缀的文件
FILE(GLOB SRC_FILES app/*.c* utils/*.c*)
# 匹配app和utils所有子目录的c开头后缀的文件
FILE(GLOB_RECURSE SRC_FILES app/*.c* utils/*.c*)

# aux_source_directory生成的是相对路径
# aux_source_directory(<dir> <variable>) 将dir下面的所有源文件储存到变量（追加）
AUX_SOURCE_DIRECTORY(./app SRC_FILES)
AUX_SOURCE_DIRECTORY(./utils SRC_FILES)
AUX_SOURCE_DIRECTORY(./common COMMON_SRC_FILES)
# 合并两个列表的数据
list(APPEND SRC_FILES ${COMMON_SRC_FILES})
# 删除列表中几个数据
list(REMOVE_ITEM SRC_FILES ${COMMON_SRC_FILES})

# 将变量指定的源文件编译成可执行文件main
add_executable(${BIN_NAME} ${SRC_FILES})
# SHARED生成动态库，STATIC生成静态库
add_library(${LIB_NAME} SHARED ${SRC_FILES})

# 给可执行文件编译设置头文件目录
target_include_directories(${BIN_NAME} PRIVATE ./includes ../includes)

# cmake的选项，命令行使用 -DBUILD_TESTING=YES
option(BUILD_TESTING "Generate test project, default is YES" YES)
# 判断是否为win32并且使用msvc，可以直接使用WIN32和MSVC判断，不用定义
if(WIN32 AND MSVC)
    # 添加编译选项
    add_compile_options(
        /wd4005             # thrift warning: WIN32_LEAN_AND_MEAN redefined
        /wd4244             # thrift warning: translate uint64_t to std::size_t
        /wd4267             # thrift warning: 'argument' : conversion from 'size_t' to 'type', possible loss of data
        /wd4275             # thrift warning: 'argument' : no matching function for call
        /wd4284             # thrift warning: 'argument' : conversion from 'type1' to 'type2', possible loss of data
        /wd4305             # thrift warning: 'argument' : truncation from 'type1' to 'type2'
        /wd4996             # thrift warning: 'argument' : 要求将sscanf等函数转换成sscanf_s等
    )
    # 添加链接选项
    add_link_options(
        /MAP
    )
endif()

########## 逻辑相关 ##########
if(WIN32)
    # 提前退出此cmake文件，不编译后续代码
    return()
endif()
```

### 1.1. if 条件判断

```cmake
# 判断是否为win32环境
if(WIN32)
    return()
elseif(UNIX)
    return()
endif()

# 判断非win32环境，NOT必须大写
if(NOT WIN32)
    return()
endif()
```

## 2. 内置变量汇总

- `PROJECT_SOURCE_DIR`: 项目工程目录
- `EXCUTABLE_OUTPUT_PATH`: 可执行文件输出目录
- `LIBRARY_OUTPUT_PATH`: 动态库输出目录
- `CMAKE_CXX_STANDARD`: C++标准

## 3. 修改CMakeCache.list的变量

三种方式修改变量

**参数的方式修改**

详情看`cmake --help`

**修改CMakeCache.txt**

有gui有文本直接修改

**添加cmake配置修改**

- 修改cmakecache的方式不好做到继承，项目内置cmake配置的方式最方便
- 如果变量为INTERNAL类型，无法通过CMakeLists.txt来修改，需要像下面这样

添加一个文件`Preload.cmake`，此文件会被cmake执行前先加载
```cmake
# SET加参数CACHE说明是修改cmakecache的变量
# SET(CMAKE_GENERATOR "MinGW Makefiles" CACHE INTERNAL "使用mingw作为默认编译" FORCE)
if(WIN32)
    SET(CMAKE_GENERATOR "MinGW Makefiles" CACHE INTERNAL "使用mingw作为默认编译" FORCE)
    # SET(CMAKE_GENERATOR "Visual Studio 14 2015" CACHE INTERNAL "使用vs 2015作为默认编译" FORCE)
    # SET(CMAKE_SYSTEM_VERSION "10.0.17763" CACHE INTERNAL "定义windows sdk为10.0" FORCE)
endif()
```

## 4. 重点方法详解

### 4.1. target_include_directories 添加头文件

```cmake
target_include_directories(<target> [SYSTEM] [AFTER|BEFORE]
                            <INTERFACE|PUBLIC|PRIVATE> [items1...]
                            [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
```

- 真实作用就是给编译选项加`-I`
- items可以使用`$<...>`的方式添加，比如使用`$<TARGET_PROPERTY:run,SOURCE_DIR>`获取run的源码路径

**有关`INTERFACE|PUBLIC|PRIVATE`的解释**

- 如果源文件(例如CPP)中包含第三方头文件，但是头文件（例如hpp）中不包含该第三方文件头，采用PRIVATE。
- 如果源文件和头文件中都包含该第三方文件头，采用PUBLIC。
    - 对于动态库来说，如果设置头文件为PUBLIC，外部在link此动态库时，会自动添加头文件目录到自己的include中
- 如果头文件中包含该第三方文件头，但是源文件(例如CPP)中不包含，采用 INTERFACE。

### 4.2. target_link_libraries 添加动态链接库

```cmake
target_link_libraries(<target>
                      <PRIVATE|PUBLIC|INTERFACE> <item>...
                     [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
```

**item取值**

1. target名字，为cmake工程中有`add_library()`定义的
2. 原始名字，cmake会查找链接库路径中是否有相应的库，比如设定`dl`会添加`-ldl`
3. 全路径，库的全路径

- 真实作用就是给编译选项加`-I`
- items可以使用`$<...>`的方式添加，比如使用`$<TARGET_PROPERTY:run,SOURCE_DIR>`获取run的源码路径

**有关`INTERFACE|PUBLIC|PRIVATE`的解释**

- 如果源文件(例如CPP)中包含第三方头文件，但是头文件（例如hpp）中不包含该第三方文件头，采用PRIVATE。
- 如果源文件和头文件中都包含该第三方文件头，采用PUBLIC。
- 如果头文件中包含该第三方文件头，但是源文件(例如CPP)中不包含，采用 INTERFACE。

### 4.3. get_target_property 获取某个target的属性

```cmake
get_target_property(<VAR> target property)
```

**几个常用的property**

- `SOURCE_DIR`: 源代码根目录

### 4.4. add_dependencies 添加依赖

- 给targetA添加targetB的依赖，targetB先编译完成才能编译targetA

```cmake
add_dependencies(<target> <dependency>...)
```

### 4.5. target_compile_definitions 添加编译定义

```cmake
target_compile_definitions(<target>
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
```

#### 示例

```cmake
target_compile_definitions(foo PUBLIC FOO)
target_compile_definitions(foo PUBLIC -DFOO)  # -D removed
target_compile_definitions(foo PUBLIC "" FOO) # "" ignored
target_compile_definitions(foo PUBLIC -D FOO) # -D becomes "", then ignored
target_compile_definitions(foo PUBLIC FOO=1)
```

## 踩坑记

# 1. windows下cmake默认指定了msvc作为编译器，想要修改为mingw

参考上面如何修改cmakecache的方法，修改`CMAKE_GENERATOR`为`MinGW Makefiles`
