---
title: nginx配置和源码分析
date: 2021-04-23 11:08:40
tags: [网络]
categories: [Program, Web]
---

# 一、配置

## 1. 配置实例

### 1.1. 80端口转443

```conf
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    rewrite ^ https://$http_host$request_uri? permanent;
}
```

### 1.2. 请求url代理到另一个地址

- proxy_pass会自动将get参数和post参数带到代理的地址去，不需要加上`$query_string`

```conf
location /test {
    # 代理地址如果不带后面地址，将会请求 http://127.0.0.1:1234/test
    proxy_pass      http://127.0.0.1:1234;

    # 代理地址如果带后面地址，将会请求 http://127.0.0.1:1234/aaa
    proxy_pass      http://127.0.0.1:1234/aaa;
}

# 假设请求的地址为 http://x.x.x.x/test/bbb
location /test/ {
    # 代理地址如果不带后面地址，将会请求 http://127.0.0.1:1234/test/bbb
    proxy_pass      http://127.0.0.1:1234;

    # 代理地址如果带后面地址，将会请求 http://127.0.0.1:1234/aaabbb
    # 由于location加了/，proxy_pass会删除/test/，剩下bbb拼接到后面url
    proxy_pass      http://127.0.0.1:1234/aaa;

    # 代理地址如果带后面地址，将会请求 http://127.0.0.1:1234/aaa/bbb
    proxy_pass      http://127.0.0.1:1234/aaa/;
}
```

### 1.3. 支持websocket

```conf
    map $http_upgrade $connection_upgrade {
        default          keep-alive;  #默认为keep-alive 可以支持 一般http请求
        'websocket'      upgrade;     #如果为websocket 则为 upgrade 可升级的。
    }
    ...
    server {
        listen       8002;
        listen       [::]:8002;
        server_name  localhost;

        location / {
                proxy_pass      http://127.0.0.1:8000;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
        }
    }
```

# 二、源码分析

## 1. 几个结构的生命周期和关系

### 1.1. ngx_http_request_t 代表一次http请求

- 和其他结构的代码关系

```cpp
// ngx_http.h
typedef struct ngx_http_request_s     ngx_http_request_t;
// ngx_http_request.h
struct ngx_http_request_s {
    ...
    ngx_connection_t                 *connection;
    ...
    ngx_http_upstream_t              *upstream;
    ...
    ngx_pool_t                       *pool;
    ...
    ngx_http_connection_t            *http_connection;
    ...
};
```

- `ngx_http_request_t`代表一次http请求
- 一次`ngx_connection_t`可以给多个`ngx_http_request_t`使用
- 每个`ngx_http_request_t`必须依赖于一个`ngx_connection_t`，并且持有`r->connection`
- 每个`ngx_http_request_t`拥有自己的内存池`r->pool`，当一次请求结束后会进行释放

#### (1) 创造

- 在`ngx_http_wait_request_handler`中进行构造，存放到`ngx_connection_t`的`data`中
- 每个http请求接收的回调中创建

```cpp
// ngx_http_request.c
static void
ngx_http_wait_request_handler(ngx_event_t *rev)
{
    ...
    c->log->action = "reading client request line";

    ngx_reusable_connection(c, 0);

    c->data = ngx_http_create_request(c);
    ...
}
```

# 踩坑记

## 1. nginx启动报`[emerg] bind() to 0.0.0.0:xxx failed (13: Permission denied)`

- 出现问题的设备是centos7，默认开启了selinux，对http监听的端口有范围限制
- 如果是小于1024是需要使用root运行，大于1024参照下面方案

### 方案1 关闭selinux

```shell
# 查看selinux当前状态
getenforce
# 设置selinux关闭
setenforce 0
```

### 方案2 使用semanage添加端口

- 安装semanage自己百度

```shell
# 查看支持的http端口列表
=> semanage port -l | grep http_port_t
http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000
# 添加端口
=> semanage port -a -t http_port_t  -p tcp 8090
```
