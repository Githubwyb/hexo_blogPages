---
title: boost库使用记录
date: 2022-05-19 15:56:20
tags:
categories: [Program, C/C++]
---

# 一、前言

## 1. cmake使用

```cmake
# 指定使用boost库的静态库还是动态库
set(Boost_USE_STATIC_LIBS ON)
# 1.70: 指定boost库最低版本1.70，可以不加
# REQUIRED: 必须找到，不然报错
# COMPONENTS: 找到filesystem和system两个模块，模块路径会加到Boost_LIBRARIES变量中，不加模块此变量为空
find_package(Boost 1.70 REQUIRED
	COMPONENTS filesystem system
)

# 头文件必须加，否则会找不到
target_include_directories(${BIN_NAME} PRIVATE
    # 第三方库头文件
    ${Boost_INCLUDE_DIR}
)

target_link_libraries(
    ${BIN_NAME} PRIVATE
    # 第三方库
    ${Boost_LIBRARIES}
)
```

# 二、使用实例

## 1. boost/filesystem/path.hpp

### 1.1. 路径字符串操作

```cpp
#include <boost/filesystem/path.hpp>

int main(int argC, char *argV[]) {
    std::string test = "C:\\ww\\asdf asdf\\aaa.txt";
    boost::filesystem::path p(test);
    LOG_INFO("{}", p.filename().string());      // aaa.txt
    return 0;
}
```

## 2. boost/format.hpp

### 2.1. 拼接变量到字符串

```cpp
#include <boost/format.hpp>

static std::string to_string(const RunLoopCB& cb) {
    const char *jsonFormat = R"({"fileName":"%1%","callThead":"%2%","calleeName":"%3%","funcName":"%4%","calleeLineNum":%5%})";
    boost::format fmt = boost::format(jsonFormat)
        % cb.fileName
        % cb.callTid
        % cb.calleeName
        % cb.funcName
        % cb.calleeLineNum;
    return fmt.str();
}
```

## 3. boost/asio.hpp

### 3.1. asio::io_context 任务队列

- post放到队列最后，等待调度
- dispatch如果在当前线程，就直接执行，不在就和post一致
- 整个队列实测是顺序执行的

#### 示例1 单线程模型

```cpp
#include <boost/asio.hpp>

#include "log.hpp"

using namespace std;

void testFunc() {
    boost::asio::io_context ioc;
    boost::asio::io_context::work worker(ioc);

    std::thread t1([&ioc]() {
        ioc.run();
        LOGI(WHAT("ioc exit"));
    });
    // detach用于让线程自由，防止函数退出时出现栈溢出
    t1.detach();
    // worker就是在这种情况下起作用，这时一直没有任务，ioc不退出
    std::this_thread::sleep_for(std::chrono::seconds(3));

    std::promise<void> p;
    int testValue = 0;
    LOGI(WHAT("push task"));
    // 添加一个任务到ioc中
    ioc.post([&testValue, &p, &ioc]() {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        testValue = 1;
        p.set_value();
    });
    p.get_future().wait();
    LOGI(WHAT("testValue {}", testValue));
}

int main(int argC, char *argV[]) {
    testFunc();
    LOGI(WHAT("main end"));
    // 这里等待用于查看worker作用域消失，ioc会退出
    std::this_thread::sleep_for(std::chrono::seconds(5));
    return 0;
}
```

输出

```
[2022-05-30 15:57:17.166] [info] [main.cpp:37] push task
[2022-05-30 15:57:20.166] [info] [main.cpp:44] testValue 1
[2022-05-30 15:57:20.167] [info] [main.cpp:30] ioc exit
[2022-05-30 15:57:20.167] [info] [main.cpp:74] main end
```

解释一下

- 使用worker防止线程退出，所以线程detach后没有打印`ioc exit`，而函数退出后，worker作用域没了，ioc就退出了
- 如果不使用worker，ioc一开始就会退出，程序将卡死在`p.get_future().wait()`

#### 示例2 多线程模型

```cpp
using namespace std;

class Test {
public:
    Test(int num) : m_work(m_ioContext) {
        cout << "Test()" << endl;
        for (int i = 0; i < num; i++) {
            m_futures.emplace_back(async(launch::async, [this]() {
                // 几个线程调用run，任务就会分发到几个线程
                m_ioContext.run();
            }));
        }
    }
    ~Test() {
        cout << "~Test()" << endl;
        // 要先停止ioContext才能等待future，否则会因为work存在卡死
        m_ioContext.stop();
        for (auto& future : m_futures) {
            future.get();
        }
    }

    void post(std::function<void()> func) {
        m_ioContext.post(func);
    }

private:
    vector<future<void>> m_futures;
    boost::asio::io_context m_ioContext;
    boost::asio::io_context::work m_work;
};

int main(int argC, char *argV[]) {
    Test test(3);

    LOGI(WHAT("push task"));
    std::vector<std::promise<void>> promises(100);
    for (size_t i = 0; i < 100; i++) {
        auto &p = promises[i];
        auto taskFunc = [i, &p]() {
            std::this_thread::sleep_for(std::chrono::milliseconds((100 - i) * 10));
            LOGI(WHAT("task {} done", i));
            p.set_value();
        };
        test.post(taskFunc);
    }
    LOGI(WHAT("push task done"));

    for (size_t i = 0; i < promises.size(); i++) {
        promises[i].get_future().get();
    }
    LOGI(WHAT("taskDone"));
    return 0;
}
```
