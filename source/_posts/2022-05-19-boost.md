---
title: boost库使用记录
date: 2022-05-19 15:56:20
tags:
categories: [Program, C/C++]
---

# 一、前言

## 1. cmake使用

```cmake
# 指定使用boost库的静态库还是动态库
set(Boost_USE_STATIC_LIBS ON)
# 1.70: 指定boost库最低版本1.70，可以不加
# REQUIRED: 必须找到，不然报错
# COMPONENTS: 找到filesystem和system两个模块，模块路径会加到Boost_LIBRARIES变量中，不加模块此变量为空
find_package(Boost 1.70 REQUIRED
	COMPONENTS filesystem system
)

# 头文件必须加，否则会找不到
target_include_directories(${BIN_NAME} PRIVATE
    # 第三方库头文件
    ${Boost_INCLUDE_DIR}
)

target_link_libraries(
    ${BIN_NAME} PRIVATE
    # 第三方库
    ${Boost_LIBRARIES}
)
```

# 二、使用实例

## 1. boost/filesystem/path.hpp

### 1.1. 路径字符串操作

```cpp
#include <boost/filesystem/path.hpp>

int main(int argC, char *argV[]) {
    std::string test = "C:\\ww\\asdf asdf\\aaa.txt";
    boost::filesystem::path p(test);
    LOG_INFO("{}", p.filename().string());      // aaa.txt
    return 0;
}
```

## 2. boost/format.hpp

### 2.1. 拼接变量到字符串

```cpp
#include <boost/format.hpp>

static std::string to_string(const RunLoopCB& cb) {
    const char *jsonFormat = R"({"fileName":"%1%","callThead":"%2%","calleeName":"%3%","funcName":"%4%","calleeLineNum":%5%})";
    boost::format fmt = boost::format(jsonFormat)
        % cb.fileName
        % cb.callTid
        % cb.calleeName
        % cb.funcName
        % cb.calleeLineNum;
    return fmt.str();
}
```

## 3. boost/asio.hpp

### 3.1. asio::io_context 任务队列

- post放到队列最后，等待调度
- dispatch如果在当前线程，就直接执行，不在就和post一致
- 整个队列实测是顺序执行的
- `stop()`调用后需要调用`restart()`才能重新进行`run()`

#### 示例1 单线程模型

```cpp
#include <boost/asio.hpp>

#include "log.hpp"

using namespace std;

void testFunc() {
    boost::asio::io_context ioc;
    boost::asio::io_context::work worker(ioc);

    std::thread t1([&ioc]() {
        ioc.run();
        LOGI(WHAT("ioc exit"));
    });
    // detach用于让线程自由，防止函数退出时出现栈溢出
    t1.detach();
    // worker就是在这种情况下起作用，这时一直没有任务，ioc不退出
    std::this_thread::sleep_for(std::chrono::seconds(3));

    std::promise<void> p;
    int testValue = 0;
    LOGI(WHAT("push task"));
    // 添加一个任务到ioc中
    ioc.post([&testValue, &p, &ioc]() {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        testValue = 1;
        p.set_value();
    });
    p.get_future().wait();
    LOGI(WHAT("testValue {}", testValue));
}

int main(int argC, char *argV[]) {
    testFunc();
    LOGI(WHAT("main end"));
    // 这里等待用于查看worker作用域消失，ioc会退出
    std::this_thread::sleep_for(std::chrono::seconds(5));
    return 0;
}
```

输出

```
[2022-05-30 15:57:17.166] [info] [main.cpp:37] push task
[2022-05-30 15:57:20.166] [info] [main.cpp:44] testValue 1
[2022-05-30 15:57:20.167] [info] [main.cpp:30] ioc exit
[2022-05-30 15:57:20.167] [info] [main.cpp:74] main end
```

解释一下

- 使用worker防止线程退出，所以线程detach后没有打印`ioc exit`，而函数退出后，worker作用域没了，ioc就退出了
- 如果不使用worker，ioc一开始就会退出，程序将卡死在`p.get_future().wait()`

#### 示例2 多线程模型

```cpp
using namespace std;

class Test {
public:
    Test(int num) : m_work(m_ioContext) {
        cout << "Test()" << endl;
        for (int i = 0; i < num; i++) {
            m_futures.emplace_back(async(launch::async, [this]() {
                // 几个线程调用run，任务就会分发到几个线程
                m_ioContext.run();
            }));
        }
    }
    ~Test() {
        cout << "~Test()" << endl;
        // 要先停止ioContext才能等待future，否则会因为work存在卡死
        m_ioContext.stop();
        for (auto& future : m_futures) {
            future.get();
        }
    }

    void post(std::function<void()> func) {
        m_ioContext.post(func);
    }

private:
    vector<future<void>> m_futures;
    boost::asio::io_context m_ioContext;
    boost::asio::io_context::work m_work;
};

int main(int argC, char *argV[]) {
    Test test(3);

    LOGI(WHAT("push task"));
    std::vector<std::promise<void>> promises(100);
    for (size_t i = 0; i < 100; i++) {
        auto &p = promises[i];
        auto taskFunc = [i, &p]() {
            std::this_thread::sleep_for(std::chrono::milliseconds((100 - i) * 10));
            LOGI(WHAT("task {} done", i));
            p.set_value();
        };
        test.post(taskFunc);
    }
    LOGI(WHAT("push task done"));

    for (size_t i = 0; i < promises.size(); i++) {
        promises[i].get_future().get();
    }
    LOGI(WHAT("taskDone"));
    return 0;
}
```

### 3.2. asio::ip::tcp::resolver dns解析

```cpp
int main(int argC, char *argV[]) {
    boost::asio::io_context ioc;
    boost::asio::io_context::work worker(ioc);
    // 要新起一个线程进行处理dns请求
    auto asyncFuture = std::async(std::launch::async, [&ioc]() {
        ioc.run();
    });

    boost::asio::ip::tcp::resolver resolver(ioc);
    boost::asio::ip::tcp::resolver::query query("www.baidu.com", "http");

    // 这里解析是同步的
    auto result = resolver.resolve(query);
    for (auto it = result.begin(); it != result.end(); ++it) {
        LOGI(WHAT("resolve success! domain={}, host_name={}, service_name={}, address={}", "www.baidu.com",
                  it->host_name(), it->service_name(), it->endpoint().address().to_string()));
    }
    ioc.stop();
    return 0;
}
```

## 4. boost/compute/detail/lru_cache.hpp

### 4.1. 源码

```cpp
// boost/compute/detail/lru_cache.hpp
template<class Key, class Value>
class lru_cache
{
public:
    typedef Key key_type;
    typedef Value value_type;
    typedef std::list<key_type> list_type;
    typedef std::map<
                key_type,
                std::pair<value_type, typename list_type::iterator>
            > map_type;

    lru_cache(size_t capacity)
        : m_capacity(capacity)
    {
    }

    ~lru_cache()
    {
    }

    size_t size() const
    {
        return m_map.size();
    }

    size_t capacity() const
    {
        return m_capacity;
    }

    bool empty() const
    {
        return m_map.empty();
    }

    bool contains(const key_type &key)
    {
        return m_map.find(key) != m_map.end();
    }

    void insert(const key_type &key, const value_type &value)
    {
        typename map_type::iterator i = m_map.find(key);
        if(i == m_map.end()){
            // insert item into the cache, but first check if it is full
            if(size() >= m_capacity){
                // cache is full, evict the least recently used item
                evict();
            }

            // insert the new item
            m_list.push_front(key);
            m_map[key] = std::make_pair(value, m_list.begin());
        }
    }

    boost::optional<value_type> get(const key_type &key)
    {
        // lookup value in the cache
        typename map_type::iterator i = m_map.find(key);
        if(i == m_map.end()){
            // value not in cache
            return boost::none;
        }

        // return the value, but first update its place in the most
        // recently used list
        typename list_type::iterator j = i->second.second;
        if(j != m_list.begin()){
            // move item to the front of the most recently used list
            m_list.erase(j);
            m_list.push_front(key);

            // update iterator in map
            j = m_list.begin();
            const value_type &value = i->second.first;
            m_map[key] = std::make_pair(value, j);

            // return the value
            return value;
        }
        else {
            // the item is already at the front of the most recently
            // used list so just return it
            return i->second.first;
        }
    }

    void clear()
    {
        m_map.clear();
        m_list.clear();
    }

private:
    void evict()
    {
        // evict item from the end of most recently used list
        typename list_type::iterator i = --m_list.end();
        m_map.erase(*i);
        m_list.erase(i);
    }

private:
    map_type m_map;
    list_type m_list;
    size_t m_capacity;
};
```

## 4.2. 使用说明

- insert只能首次插入key，已存在的key调用insert会没有任何效果
- get返回的不是value，而是`boost::optional`，需要使用其再次调用get才能返回value
  - get不存在的key将返回`boost::none`，如果对其调用get会直接抛异常
- get会将对应的key放到最前面，但get出来的值是一个右值，修改不会影响lru中的value
- contains不会影响顺序
