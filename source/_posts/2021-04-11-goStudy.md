---
title: go语言学习
date: 2021-04-11 02:06:33
tags:
categories: [Program, Web]
top: 100
---

# 一、前言

## 环境

```shell
=> go version
go version go1.16.4 linux/amd64
```

# 二、语法相关

## 1. 基本类型

### 1.1. 去除变量未定义提示

```go
_ = varA
```

### 1.2. 类型及转换

#### int

```go
// 转string
fmt.Sprint(123)
```

#### float32 float64

```go
// 转int
var f float32 = 1
var a int = int(f)
```

#### string

```go
// 转[]byte
var jsonStr string
jsonByte := []byte(jsonStr)

// 转byte
testByte := jsonStr[0]

// 转uint64
// The bitSize argument specifies the integer type
// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
// correspond to uint, uint8, uint16, uint32, and uint64.
var num uint64
num, err := strconv.ParseUint("1234", 10, 64)

// 转int64
// The bitSize argument specifies the integer type
// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
// correspond to int, int8, int16, int32, and int64.
var num uint64
num, err := strconv.ParseInt("1234", 10, 64)
```

**单引号，双引号，反引号的区别**

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Printf("%c %d\n", 'a', 'a')
    fmt.Printf("a\n")
    fmt.Printf("%s\n", `a\n`)
}
```

输出

```shell
a 97
a
a\n
```

**字符串截取**

```go
outStr := "abcdefg"
fmt.Println(outStr[0])		// 97，被识别成byte打印了
fmt.Println(outStr[:3])		// abc
fmt.Println(outStr[3:5])	// de
fmt.Println(outStr[5:])		// fg

fmt.Println(outStr[:-2])	// 不支持，索引仅支持正数
```

**遍历**

```go
s := "abc"
for i := range(s) {
	fmt.Println(i)
}
/* 输出
0
1
2
*/

for i, v := range(s) {
	fmt.Println(i, byte(v))
}
/* 输出
0 a
1 b
2 c
*/
```

#### []byte

```go
// 转string
data := []byte("aaa")
str := string(data)
```

#### interface

**类型判断**

类型断言

```go
var f interface{}

if _, ok = f.(string); !ok {
	fmt.Println("f type is not string")
}
```

switch类型判断

```go
var f interface{}

switch(f.(type)) {
case string:
	fmt.Println("f type is string")

case int:
	fmt.Println("f type is int")

default:
	fmt.Println("f type is unknown")
}
```

## 2. map

### 2.1. 一些基本操作

```go
/****** map初始化 ******/
xxxMap := make(map[string]interface{})

/****** 判断map是否存在key ******/
if _, ok := xxxMap[key]; ok {
    // 存在key
}

/****** 遍历map ******/
// key, value
for key, value := range xxxMap {
    // 操作map
}
// 只要key
for key := range xxxMap {
	// do something
}
```

### 注意事项

- `var xxx map[string]interface{}`定义的xxx是一个空指针，没有指向任何地址，不能进行赋值
- 初始化map需要使用make

## 3. array

### 3.1. 一些基本操作

```go
/****** array初始化 ******/
arr0 := [...]int{0, 1}
arr1 := [...]int{0, 1}

/****** 遍历 ******/
for _, v := range arr0 {
	fmt.Println(v)
}
```

## 4. slice

### 4.1. 一些基本操作

```go
/****** slice初始化 ******/
s0 := []int{0, 1}
s1 := []int{0, 1}
s2 := make([]int, 5)		// len 5, cap 5
s3 := make([]int, 0, 10)	// len 0, cap 10

/****** slice添加元素 ******/
// go对append有处理，如果赋值给原切片，且切片空间足够，不会新申请内存
// 赋值给原切片，空间不够，会申请cap的两倍大小空间
// 如果赋值给不同切片，会新申请内存，不会更改原切片
s0 = append(s0, 2)
s0 = append(s0, 3, 4)
// 切片合并，其中s1...意味着将s1拆分成元素传入append
// 相当于调用添加多个元素
s0 = append(s0, s1...)

/****** slice删除元素 ******/
s0 = s0[2:]				// 截取2到末尾，删除前两个元素
s1 = s1[:len(s1)-2]		// 开头到倒数第3个元素，删除后两个元素
s0 = s0[:0]				// 清理slice，不改变cap

/****** 遍历 ******/
for _, v := range s0 {
	fmt.Println(v)
}
```

### 4.2. 新增和删除的优化

#### 1) 新增的优化

```go
// go对append有处理，如果赋值给原切片，且切片空间足够，不会新申请内存
// 赋值给原切片，空间不够，会申请cap的两倍大小空间
// 如果赋值给不同切片，会新申请内存，不会更改原切片
s0 = append(s0, 2)
```

#### 2) 删除的优化

```go
testArr := []int{2, 7, 4, 9, 1, 4, 8}
fmt.Println(cap(testArr))		// 7
testArr = testArr[:len(testArr)-1]
fmt.Println(cap(testArr))		// 7
testArr = testArr[1:len(testArr)-1]
fmt.Println(cap(testArr))		// 6
testArr = testArr[:0]			// 清理slice，不改变容量
fmt.Println(cap(testArr))		// 6
```

- 从打印猜测，如果删除slice末尾元素赋值给同一个slice，不会改变cap，直接把len减1
- 如果删除slice的头部元素，会直接把数组data段的首地址后移，cap会减少

## 5. 流程控制语句

### 5.1. for 循环

```go
// 死循环
for {
	...
}
// for i 形式
for i := 0; i < len(a); i++ {
	...
}
// 遍历
for _, v := range(arr) {
	...
}
// do while
for {
	...
	if expression {
		break
	}
}
// while
for {
	if expression {
		break
	}
	...
}
```

## 6. 函数

### 6.1. 定义和返回值

```go
// 正常定义
func test(a int) int {
	return a + 1
}
// 多返回值
func test(a int) (int, int) {
	return a+1, a-1
}
// nil 返回初始化定义，仅对slice和map生效
func test(a int) []int {
	return nil	// 相当于return []int{}
}
// 返回值提前声明
func test(a int) (result int) {
	result = a + 1
	return
}
```

### 6.2. 值传递

#### (1) go函数都是值传递

```go
func changeDatas(intData int, strData string, arrData [3]int) {
	intData += 2
	strData += "bbb"
	arrData[0] = 999
}

func main() {
	intData := 1
	strData := "aaa"
	arrData := [...]int{1, 2, 3}
	fmt.Println(intData, strData, arrData)
	changeDatas(intData, strData, arrData)
	fmt.Println(intData, strData, arrData)
}
```

输出

```
1 aaa [1 2 3]
1 aaa [1 2 3]
```

#### (2) slice、map、channel都是引用类型，即便是值传递，结构内部还是指向原来的引用对象，所以函数体内可以直接修改元素。

- 也就是传递了一个结构体，结构体里面有一个指针指向数据段，所以可以直接修改元素

<img src="2022-02-18-01.jpg">

```go
func changeDatas(sliceData []int, mapData map[string]int) {
	sliceData[0] = 999
	mapData["test"] = 123
}

func main() {
	sliceData := []int{1, 2, 3}
	mapData := make(map[string]int)
	fmt.Println(sliceData, mapData)
	changeDatas(sliceData, mapData)
	fmt.Println(sliceData, mapData)
}
```

输出

```
[1 2 3] map[]
[999 2 3] map[test:123]
```

#### (3) 如果slice触发扩容，data会指向新的底层数组，而不指向外部的底层数组了。所以之后再修改slice，不会对外部的slice造成影响。

```go
func changeDatas(sliceData []int) {
	sliceData[0] = 999                   // 修改了外部变量
	sliceData = append(sliceData, 12345) // 扩容重新赋值data
	sliceData[1] = 777                   // 无法修改外部变量，修改的是重新建的data
}

func main() {
	sliceData := []int{1, 2, 3, 4}
	fmt.Println(sliceData)
	changeDatas(sliceData)
	fmt.Println(sliceData)
}
```

结果

```
[1 2 3 4]
[999 2 3 4]
```


## 7. 组合赋值

```go
a, b := 1+1, 2+2
```

## 8. i++、i--

```go
i++		// 理解成 i+=1
j=i++	// error，i++是i+=1，是语句，非表达式，不能赋值
++i		// error，不存在++i
```

## 9. const & iota

### 9.1. itoa

参考[golang const 内itoa 用法详解及优劣分析](https://www.jianshu.com/p/aad37a6c81a2)

#### (1) 每次 const 出现时，都会让 iota 初始化为0

```go
const a = iota // a = 0
const (
  b = iota     // b = 0
  c            // c = 1
)
```

#### (2) 自定义类型

自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。

```go
type Newtype int

const (
    T1 Newtype = iota // 0
    T2                // 1
    T3                // 2
    T4                // 3
)
```

#### (3) 可跳过的值

```go
type AudioOutput int

const (
    OutMute AudioOutput = iota // 0
    OutMono                    // 1
    OutStereo                  // 2
    _
    _
    OutSurround                // 5
)
```

#### (4) 位掩码表达式

```go
type Allergen int

const (
    IgEggs Allergen = 1 << iota // 1 << 0 which is 00000001
    IgChocolate                         // 1 << 1 which is 00000010
    IgNuts                              // 1 << 2 which is 00000100
    IgStrawberries                      // 1 << 3 which is 00001000
    IgShellfish                         // 1 << 4 which is 00010000
)
```

#### (5) 定义数量级

```go
type ByteSize float64

const (
    _           = iota                   // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)       // 1 << (10*1)
    MB                                   // 1 << (10*2)
    GB                                   // 1 << (10*3)
    TB                                   // 1 << (10*4)
    PB                                   // 1 << (10*5)
    EB                                   // 1 << (10*6)
    ZB                                   // 1 << (10*7)
    YB                                   // 1 << (10*8)
)
```

#### (6) 定义在一行的情况

- 跟普通形式 没什么不同
- iota 在下一行增长，而不是立即取得它的引用。

```go
const (
	Apple, Banana     = iota + 1, iota + 2 // 0+1, 0+2
	Cherimoya, Durian                      // 1+1, 1+2
	Elderberry, Fig                        // 2+1, 2+2
)

/*
1, 2
2, 3
3, 4
*/
```

#### (7) 中间插队

中间插队时，iota 会被覆盖掉 不再继续自增。但是用另一个 iota 接一下，又会继续自增。
示例如下，中间插入了5、3和6，3下面有itoa接，6没有。

```go
const(
    a = iota		// 0	itoa = 0
    b = 5			// 5	itoa = 1
    c = 3			// 3	itoa = 2
    d = iota		// 3	itoa = 3
    e = 6			// 6
    f				// 6
    g				// 6
)
```

## 10. 并发

### 10.1. 基础概念

- [go调度详解](https://zhuanlan.zhihu.com/p/27056944)

**和线程的区别**

- OS线程（操作系统线程）一本都有固定的栈内存（通常为2MB）
- 一个 goroutine 的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine 的栈不是固定的，他可以按需增大和缩小，grorutine的栈大小限制可以达到1GB，但极少情况下会到1GB。所以在Go语言中一次创建十万左右的 grorutine 也是可以的。

**和线程的关系**

- 一个操作系统线程对应用户态多个goroutine。
- go程序可以同时使用多个操作系统线程。
- goroutine和OS线程是多对多的关系，即m:n。

**其他**

- 1.5版本之前，go仅占用一个核执行
- 1.5之后，默认使用所有核

### 10.2. `sync.WaitGroup` 等待退出

```go
package main

import (
    "fmt"
    "sync"
)

var wg sync.WaitGroup

func hello(i int) {
    fmt.Println("Hello", i)
    wg.Done()
}

func main() {
    fmt.Println("Hello world, main")
    for i := 1; i < 1000; i++ {
        wg.Add(1)
        go hello(i)
    }
    wg.Wait()
}
```

### 10.3. `runtime.GOMAXPROCS(i int)` 限定占用核心数

- go可以设定goroutine占用的核心数

```go
package main

import (
    "fmt"
    "sync"
	"runtime"
)

var wg sync.WaitGroup

func hello(i int) {
    fmt.Println("Hello", i)
    wg.Done()
}

func main() {
	runtime.GOMAXPROCS(1)
    fmt.Println("Hello world, main")
    for i := 1; i < 1000; i++ {
        wg.Add(1)
        go hello(i)
    }
    wg.Wait()
}
```

### 10.4. 互斥锁

```go

```

## 11. 面向对象编程

### 11.1. 属性和方法

- go中使用结构体可以代表类
- 定义接受者代表方法

```go
package main

import (
    "fmt"
)

// Rectangle define class
type Rectangle struct {
    X int
    Y int
}

// Area define method
func (r *Rectangle) Area() int {
    return r.X * r.Y
}

func main() {
    rec := Rectangle{
        X: 5,
        Y: 10,
    }
    fmt.Println(rec.Area())
}
```

### 11.2. 访问权限

- 首字母大小写可以控制访问权限
- 不过小写对整个package都可以访问，外部不可以访问

### 11.3. 继承

- 结构体里面直接定义另一个结构体就可以实现继承
- 但是初始化不能直接初始化父类的属性
- 同一个包内，大小写都可以访问到

```go
package main

import "fmt"

// Rectangle define class
type Rectangle struct {
    x int
    Y int
}

// Area define method
func (r *Rectangle) Area() int {
    return r.x * r.Y
}

type testRec struct {
    Rectangle
}

// Area 可以调用，也可以像下面这样直接重写
// func (r *testRec) Area() int {
//     return r.x * r.Y
// }

func main() {
    rec := testRec{}
    rec.x = 10
    rec.Y = 4
    fmt.Println(rec.Area())
}
```

### 11.4. 多态

- 多态在go里面更多把思想转成接口
- 对外提供接口，但是存在不同实现

```go
```

### 11.5. 析构函数

- go可以给类设置析构函数，但是析构时机是GC触发的时机
- 如果进程直接退出，由操作系统回收内存，不会触发析构函数

```go
package main

import (
	"fmt"
	"runtime"
)

type testT struct {
	a    int
	next *testT
}

func main() {
	var root testT
	runtime.SetFinalizer(&root, func (tmp *testT)  {
		fmt.Println("hhh", tmp.a)
	})
}
```

## 12. 指针

### 12.1. int转指针

- go中限制了指针类型的转换，不允许将int转成指针类型
- 但是，转换一下想法，用二级指针进行赋值即可

```go
var tmp **testT
tmp1 := 0x111111111
tmp = (**testT)(unsafe.Pointer(&tmp1))
fmt.Printf("%p", *tmp)
```

## 13. GC 垃圾回收机制

- GC（Garbage Collection）
- 下面内容参考自 [图解golang垃圾回收机制](https://zhuanlan.zhihu.com/p/390926887)

### 13.1. 内存管理

程序在内存上被分为堆区、栈区、全局数据区、代码段、数据区五个部分。对于C++等早期编程语言栈上的内存由编译器管理回收，堆上的内存空间需要编程人员负责申请与释放。在Go中栈上内存仍由编译器负责管理回收，而堆上的内存由编译器和垃圾收集器负责管理回收，给编程人员带来了极大的便利性。

<img src="2022-04-02-02.jpg" />

### 13.2. GC触发时机

触发GC有俩个条件，一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量GOGC，之后堆内存达到上一次垃圾收集的2倍时才会触发GC。二是如果一定时间内没有触发，就会触发新的循环，该触发条件由runtime.forcegcperiod变量控制，默认为2分钟。

### 13.3. GC带来的便利和坑

#### 1) 便利

```go
import (
	"fmt"
	"runtime"
	"time"
	"strconv"
	"unsafe"
)

type testT struct {
	a    int
	next *testT
}

func testFunc(root *testT) (arr []string) {
	for i := 0; i < 5; i++ {
		var tmp testT
		tmp.a = i
		// 引用了局部变量的地址，此变量在编译时会放到堆上而不是栈上
		root.next = &tmp
		arr = append(arr, fmt.Sprintf("%p", &tmp))
		// 这里加上析构函数查看触发时机
		runtime.SetFinalizer(&tmp, func (tmp *testT)  {
			fmt.Println("hhh", tmp.a)
		})
		root = root.next
	}
	return
}

func main() {
	var root testT

	arr := testFunc(&root)
	// 手动触发GC，这里什么都回收不掉，因为后面还在使用
	for i := 0; i < 10; i++ {
		time.Sleep(time.Second)
		runtime.GC()
	}
	for e := &root; e != nil; e = e.next {
		fmt.Println(e.a)
	}

	// 手动触发GC，GC一次回收一个变量
	for i := 0; i < 10; i++ {
		time.Sleep(time.Second)
		runtime.GC()
	}
	// 如果没有下面这一句使用了root，上面就会连带root的内存也回收掉，不会等到函数退出，因为分析后续没有再使用局部变量
	// 有下面这一句使用了root，上面就不会回收root和子节点
	fmt.Println(root.a)
}
```

# 三、标准库

## 1. encoding/json

### 1.1. 一些基本操作

```go
package main

import (
	"encoding/json"
)

func main() {
	/****** 将json字符串序列化成go对象 ******/
	// 先marshal在unmarshal可以让一个未知的interface确定内部类型
	// Unmarshal可以将一个json字符串解析到一个特定的格式下
	// json.Unmarshal会将数字解析成float64
	json.Unmarshal(jsonBytes, &target)

	/****** 将go对象转成json字符串 ******/
	var f interface{}
	jsonBytes, err := json.Marshal(&f)
	// 格式化的字符串，第二个是前缀，第三个是缩进符号
	jsonIndentBytes, err := json.MarshalIndent(&f, "", "    ")
}
```

### 1.2. key排序转json

- go默认对`map[string]interface{}`转json按照key升序转化
- 想要对key排序只能通过结构体的方式，转json会按照结构体的顺序转化
- 为空的key不想输出，可以加上`omitempty`

```go
type outT struct {
	Type string `json:"type,omitempty"`
	Name string `json:"name,omitempty"`
}

func main() {
	var f outT
	str, _ := json.Marshal(&f)	// {}
}
```

### 注意事项

- 数字类型在Unmarshal之后会转成float64，只能断言为float64

## 2. testing 单测

```go
package service

import (
	"encoding/json"
	"errors"
	"reflect"
	"sort"
	"testing"

	"github.com/gin-gonic/gin"

	. "github.com/agiledragon/gomonkey"
	. "github.com/smartystreets/goconvey/convey"
)

func TestFunc(t *testing.T) {
	sess := session.Session{}
	var s *session.Session

    // hook类的成员函数Commit
	patch := ApplyMethod(reflect.TypeOf(s), "Commit", func(_ *session.Session) error { return nil })
	defer patch.Reset()

    // 使用Convey包裹，可以按照分组测试
	Convey("TestFunc", t, func() {
		Convey("正常流程", func() {
			Convey("插入单个数据", func() {
				sess.New()
                ...
                // So确定
				So(tmp, ShouldResemble, []string{"aaa"})
			})
		})
		Convey("异常流程", func() {
			Convey("GetSessionData出错", func() {
				sess.New()
				...
				patch1 := ApplyMethod(reflect.TypeOf(s), "GetSessionData",
					func(_ *session.Session, _ string) (interface{}, error) {
						return nil, errors.New("testErr")
					})
				...
				So(tmp, ShouldResemble, []string{})
				patch1.Reset()
				...
				So(tmp, ShouldResemble, []string{"bbb"})
			})
		})
	})
}
```

### 2.2. 性能分析

参考[go 性能优化之 benchmark + pprof](https://zhuanlan.zhihu.com/p/332613357)

## 3. flag 控制台参数解析

### 3.1. 获取命令行参数

```go
package main

import (
	"fmt"
	"flag"
)

func main() {
	// 在使用前先调用此函数解析参数，不然会返回空
	flag.Parse()
	// 打印第一个参数
	fmt.Println(flag.Arg(0))
	// 打印所有非flag的参数
	fmt.Println(flag.Args())
	// 打印参数个数
	fmt.Println(flag.NArg())
}
```

输出

```shell
=> go run main.go a -a -b -asdfsaf cccc
a
[a -a -b -asdfsaf ccc]
5
```

## 4. path/filepath 目录操作库

### 4.1. 遍历目录下所有文件和目录，类似 `find xxx`

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "path/filepath"
)

func getFileList(path string) {
    err := filepath.Walk(path, func(path string, f os.FileInfo, err error) error {
        if f == nil {
            return err
        }
        if f.IsDir() {
            return nil
        }
        println(path)
        return nil
    })
    if err != nil {
        fmt.Printf("filepath.Walk() return %v\n", err)
    }
}

func main() {
    flag.Parse()
	var root string
    root = flag.Arg(0)
    getFileList(root)
}
```

输出

```shell
=> go run main.go .
go.mod
main.go
=> go run main.go ./
go.mod
main.go
=> go run main.go ../
../test/go.mod
../test/main.go
=> go run main.go /path/to/test
/path/to/test/go.mod
/path/to/test/main.go
```

## 5. os/exec 命令行调用

### 5.1. 阻塞式等待返回，并输出stdout

```go
package main

import (
    "bytes"
    "fmt"
    "os/exec"
)

func execShell(s string) (string, error) {
    cmd := exec.Command("/bin/bash", "-c", s)

    var out bytes.Buffer
    cmd.Stdout = &out

    err := cmd.Run()
    if err != nil {
        fmt.Printf("%v\n", err)
    }

    return out.String(), err
}

func main() {
    fmt.Println(execShell("ls /"))
}
```

## 6. net/http http网络请求库

### 6.1. 发送post请求

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func main() {
	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
    if err != nil {
        fmt.Println(err)
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(string(body))
}
```

### 6.2. 忽略https的证书错误

#### (1) 修改默认客户端

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
    "crypto/tls"
)

func main() {
	http.DefaultClient.Transport = &http.Transport{
        TLSClientConfig: &tls.Config{
            InsecureSkipVerify: true,
        },
    }

	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
	...
}
```

## 7. strings 字符串操作库

### 7.1. 字符串替换

```go
package main

import (
	"strings"
)

func main() {
	outStr := '{"a":"123"}'
	// 将json中的双引号全部替换为单引号
	outStr = strings.ReplaceAll(outStr, `"`, `'`)
}
```

### 7.2. 裁剪两端字符串

- 只能裁剪两端的字符串，中间的不会裁剪

```go
outStr := "abffffffffabfffffffab"
outStr = strings.Trim(outStr, "ab")		// ffffffffabfffffff
```

### 7.3. 字符串分割

**Split**

- 根据某字符串分割

```go
arr := strings.Split("a,b,c", ",")	// [a b c]
```

**Fields**

- 根据空格分割，多个空格视为一个

```go
arr := strings.Fields("a b  c   d") // [a b c d]
```

## 8. encoding/hex 十六进制操作库

### 8.1. 将十六进制字符串转成数组

```go
arr, err := hex.DecodeString("aabbcc")	// [170 187 204]
```

### 8.2. 将[]byte按照十六进制打印成字符串

```go
hexStr := hex.EncodeToString([]byte("123456"))	// 313233343536
```

## 9. io/ioutil io操作

### 9.1. 文件读取

```go
contentBytes, err := ioutil.ReadFile("/a/b/c.txt")
```

## 10. os 系统操作

### 10.1. 判断目录是否存在

```go
_, err := os.Stat("./")
if err != nil && os.IsNotExist(err) {
	// 目录不存在
}
```

## 11. stronv

```go
package main
import (
    "strconv"
    "fmt"
)
func main() {
    // 使用ParseFloat解析浮点数，64是说明使用多少位
    // 精度来解析
    f, _ := strconv.ParseFloat("1.234", 64)
    fmt.Println(f)

    // 对于ParseInt函数，0 表示从字符串推断整型进制，
    // 则表示返回结果的位数
    i, _ := strconv.ParseInt("123", 0, 64)
    fmt.Println(i)

    // ParseInt能够解析出16进制的数字
    d, _ := strconv.ParseInt("0x1c8", 0, 64)
    fmt.Println(d)

    // 还可以使用ParseUint函数
    u, _ := strconv.ParseUint("789", 0, 64)
    fmt.Println(u)

    // Atoi是解析10进制整型的快捷方法
    k, _ := strconv.Atoi("135")
    fmt.Println(k)

    // 解析函数在遇到无法解析的输入时，会返回错误
    _, e := strconv.Atoi("wat")
    fmt.Println(e)
}
```

## 12. net 网络库

### 12.1. udp发送和接受

**客户端**

```go
package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
)

func main() {
	flag.Parse()
	if flag.NArg() < 2 {
		log.Fatalln("Must input 2 params")
	}
	serverAddr := flag.Arg(0)
	filePath := flag.Arg(1)

	fmt.Printf("client, serverAddr: %s, filePath: %s\r\n", serverAddr, filePath)

	conn, err := net.Dial("udp", serverAddr)
	if err != nil {
		log.Fatalln(err)
	}
	defer conn.Close()

	f, err := os.Open(filePath)
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()

	buf := make([]byte, 50*1024)
	count := 0
	i := 0
	for {
		n, err := f.Read(buf)
		if err != nil {
			if err == io.EOF {
				break
			} else {
				log.Fatalln(err)
			}
		}
		sendSize, err := conn.Write(buf[:n])
		if err != nil {
			log.Fatalln(err)
		}
		count += sendSize

		msg := make([]byte, 128)
		_, err = conn.Read(msg)
		if err != nil {
			log.Fatalln(err)
		}

		fmt.Printf("%d, Send %d, check %s\r\n", i, n, string(msg))
		i++
	}

	fmt.Printf("Send %s to %s success, size %d", serverAddr, filePath, count)
}
```

**服务端**

```go
package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"os"
)

func main() {
	flag.Parse()
	if flag.NArg() < 2 {
		log.Fatalln("Must input 2 params")
	}
	serverAddr := flag.Arg(0)
	filePath := flag.Arg(1)

	fmt.Printf("Hello, main, serverAddr: %s, filePath: %s\r\n", serverAddr, filePath)

	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	addr, err := net.ResolveUDPAddr("udp", serverAddr)
	if err != nil {
		log.Fatalln(err)
	}

	conn, err := net.ListenUDP("udp", addr)
	if err != nil {
		log.Fatalln(err)
	}
	defer conn.Close()

	i := 0
	for {
		data := make([]byte, 100*1024)
		n, rAddr, err := conn.ReadFromUDP(data)
		if err != nil {
			fmt.Println(err)
			continue
		}

		fmt.Printf("%d, Recieved from %s size %d\r\n", i, rAddr.String(), n)

		f.Write(data[:n])
		i++

		_, err = conn.WriteToUDP([]byte(fmt.Sprintf("%d", n)), rAddr)
		if err != nil {
			fmt.Println(err)
			continue
		}
	}
}
```

## 13. time 时间库

### 13.1. 时间戳操作

```go
package main

import (
	"time"
)

func main() {
	timestampS := time.Now().Unix()		// 秒级时间戳
}
```

## 14. sort 排序

### 14.1. 基本类型排序

#### 1) 升序

```go
package main

import (
	"sort"
)

func main() string {
	var queryKeyList []string
	var intList []int

	sort.Strings(queryKeyList)
	sort.Ints(intList)
}
```

#### 2) 降序

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	testArr := []int{2, 7, 4, 9, 1, 4, 8}

	sort.Sort(sort.Reverse(sort.IntSlice(testArr)))
	fmt.Println(testArr)
}
```

- 解释一下上面的代码，`sort.IntSlice(testArr)`是将`[]int`强转成`sort.IntSlice`类型，类型定义了sort需要的三个函数，本质上还是`[]int`
- `sort.IntSlice`是`sort.Interface`的一个子类实现
- `sort.Reverse(xxx)`将传入的`sort.Interface`转成`sort.reverse`类型返回
- 同样`sort.reverse`也是`sort.Interface`的一个子类实现，将`Less()`方法重写，反着调用原方法
- `sort.Sort()`将`sort.Interface`进行排序

## 15. image 图像库

### 15.1. png处理

```go
package main

import (
	"bytes"
	"fmt"
	"image"
	"image/color"
	"image/png"		// 包含这个才能解析png图片
	"io/ioutil"
	"os"
)

func main() {
	originByte, _ := ioutil.ReadFile("./test.png")
	originBuffer := bytes.NewBuffer(originByte)
	originImg, filename, err := image.Decode(originBuffer)
	if err != nil {
		return err.Error()
	}
	fmt.Println(filename)	// png
	imgBounds := img.Bounds()
	imgX := imgBounds.Dx()		// 宽度
	imgY := imgBounds.Dy()		// 高度

	firstRgba := img.At(0, 0)	// 获取一个位置的像素点
	r, g, b, a := firstRgba.RGBA()

	// 创建一个新的图片，范围是100x100
	newImg := image.NewRGBA(image.Rectangle{
		Min: image.Point{X: 0, Y: 0},
		Max: image.Point{X: 100, Y: 100},
	})
	// 坐标 (5, 5) 涂黑
	newImg.SetRGBA(5, 5, color.RGBA{
		R: 0,
		B: 0,
		G: 0,
		A: 255,		// 不透明
	})

	// 保存到output.png
	f, _ := os.Create("./output.png")
	png.Encode(f, newImg)
	defer f.Close()
}
```

## 16. container/list 双向链表

- value可以是任意类型的值

### 16.1. 基本操作

```go
// 初始化
var tmp list.List
tmp.PushBack(1)  // 向后插入
tmp.PushFront(3) // 向前插入
// 遍历
for e := tmp.Front(); e != nil; e = e.Next() {
	fmt.Println(e.Value)
}
// 删除
for e := tmp.Front(); e != nil; e = e.Next() {
	if e.Value == 3 {
		tmp.Remove(e)
		break
	}
}
```

# 四、go命令相关

## 1. go test 执行单测用例

```shell
########## 指定目录 ##########
# 执行当前目录下所有单测文件
go test
# 执行当前package的某个子目录单测文件
go test [package]/[dir]

########## 指定函数 ##########
# 执行特定函数
go test -run ^testFunc$
# 执行多个特定函数
go test -run ^(testFunc|testFunc1)$

########## 设定超时时间 ##########
go test -timeout 30s

########## 打印详细信息 ##########
# 默认成功不会打印fmt.Println等，加上-v就会打印
go test -v
```

## 2. go build 编译二进制

- go build不区分平台，可以在任意系统上编译其他大多数系统的版本

### 2.1. windows 32bit和64bit

```shell
# 32位编译
go env -w GOOS=windows
go env -w GOARCH=386
go build
go env -u GOARCH
go env -u GOOS

# 64位编译
go env -w GOOS=windows
go env -w GOARCH=amd64
go build
go env -u GOARCH
go env -u GOOS
```

### 2.2. 全平台编译makefile示例

```makefile
TARGET_NAME		= testaaa
BUILD_CMD		= go build

all: $(TARGET_NAME)_x86.exe $(TARGET_NAME)_x64.exe $(TARGET_NAME)_amd64 $(TARGET_NAME)_arm64
clean:
	rm -f $(TARGET_NAME)_x86.exe $(TARGET_NAME)_x64.exe $(TARGET_NAME)_amd64 $(TARGET_NAME)_arm64

$(TARGET_NAME)_x86.exe: *.go
	go env -w GOOS=windows
	go env -w GOARCH=386
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_x64.exe: *.go
	go env -w GOOS=windows
	go env -w GOARCH=amd64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_amd64: *.go
	go env -w GOOS=linux
	go env -w GOARCH=amd64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_arm64: *.go
	go env -w GOOS=linux
	go env -w GOARCH=arm64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH
```

### 2.3. 编译给c调用的动态库

**代码上**

- 必须有`package main`和main函数，但是可以什么都不做
- 必须包含`import "C"`
- 要导出的函数必须加上`//export funcName`，export前没有空格
- 导出函数本身无所谓首字母大小写

```go
package main

import "fmt"
import "C"

// Rectangle define class
type Rectangle struct {
    x int
    y int
}

// Area define method
func (r *Rectangle) Area() int {
    return r.x * r.y
}

//export test
func test() {
    rec := Rectangle{
        x: 14,
        y: 34,
    }
    fmt.Println(rec.Area())
}

func main() {
}
```

**编译**

```shell
# 要先安装标准库，会生成目录到 /usr/lib/go/pkg/linux_[arch]_dynlink/
go install -buildmode=shared -linkshared std
# 编译C静态库
go build -buildmode=c-shared -linkshared -o libtest.so
```

**结果**

- 会在当前目录生成一个静态库文件（`libtest.so`）一个头文件（`libtest.h`）
- strip后查看`libtest.so`，函数已经导出，依赖上述生成的目录下的`libstd.so`

```shell
=> strip libtest.so
=> readelf -Ws libtest.so

Symbol table '.dynsym' contains 33 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.17 (2)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.17 (2)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.morestack_noctxt
     7: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.int
     8: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.*os.File
     9: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND os.Stdout
    10: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.io.Writer
    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.addmoduledata
    12: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND os.(*File).Write
    13: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND go.link.abihash.libstd.so
    14: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.unreachableMethod
    15: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.convT64
    16: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _rt0_arm64_linux_lib
    17: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND runtime.lastmoduledatap
    18: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND runtime.tlsg
    19: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fmt.Fprintln
    20: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND __stack_chk_guard@GLIBC_2.17 (3)
    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _cgo_wait_runtime_init_done
    22: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND crosscall2
    23: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _cgo_release_context
    24: 000000000001f950     8 OBJECT  GLOBAL DEFAULT   19 _rt0_arm64_linux_lib.ptr
    25: 0000000000020238     0 NOTYPE  GLOBAL DEFAULT   18 _edata
    26: 0000000000020239     0 NOTYPE  GLOBAL DEFAULT   18 _end
    27: 0000000000001270    64 FUNC    GLOBAL DEFAULT   13 _cgoexp_f70364e750d1_test
    28: 00000000000012b0   144 FUNC    GLOBAL DEFAULT   13 main.test
    29: 0000000000001350   128 FUNC    GLOBAL DEFAULT   13 test
    30: 0000000000020238     0 NOTYPE  GLOBAL DEFAULT   18 __bss_start
    31: 000000000001f988    32 OBJECT  GLOBAL DEFAULT   20 go.itab.*os.File,io.Writer
    32: 000000000001f970    24 OBJECT  GLOBAL DEFAULT   20 runtime.textsectionmap

# 可以看到依赖了go自己的标准库和libc的库
=> readelf -d libtest.so

Dynamic section at offset 0xfce8 contains 32 entries:
  Tag        Type                         Name/Value
 0x0000000000000003 (PLTGOT)             0x1ff88
 0x0000000000000002 (PLTRELSZ)           264 (bytes)
 0x0000000000000017 (JMPREL)             0xf90
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000007 (RELA)               0x948
 0x0000000000000008 (RELASZ)             1608 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffff9 (RELACOUNT)          55
 0x0000000000000006 (SYMTAB)             0x288
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000005 (STRTAB)             0x5a0
 0x000000000000000a (STRSZ)              700 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x860
 0x0000000000000001 (NEEDED)             Shared library: [libstd.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-aarch64.so.1]
 0x000000000000000c (INIT)               0x1098
 0x000000000000000d (FINI)               0x13d0
 0x000000000000001a (FINI_ARRAY)         0x1f940
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x0000000000000019 (INIT_ARRAY)         0x1f948
 0x000000000000001b (INIT_ARRAYSZ)       24 (bytes)
 0x000000000000001d (RUNPATH)            Library runpath: [/usr/lib/go/pkg/linux_arm64_dynlink/]
 0x0000000000000010 (SYMBOLIC)           0x0
 0x000000000000001e (FLAGS)              SYMBOLIC BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW NODELETE
 0x000000006ffffff0 (VERSYM)             0x8a8
 0x000000006ffffffc (VERDEF)             0x8ec
 0x000000006ffffffd (VERDEFNUM)          1
 0x000000006ffffffe (VERNEED)            0x908
 0x000000006fffffff (VERNEEDNUM)         2
 0x0000000000000000 (NULL)               0x0
```

## 3. go env 设置环境变量

```shell
# 设置环境变量
go env -w xxx=xx
# 恢复环境变量到默认值
go env -u xxx
```

**实例**

- 可以写到makefile中，跨平台的makefile

```makefile
main.exe: main.go
	go env -w GOOS=windows
	go build
	go env -u GOOS
```

# 五、框架

## 1. 工程知识

### 1.1. go.mod

- `go.mod`是go工程用来管理包使用的，类似于nodejs的`package.json`文件

#### (1) 创建新工程

**1. 先生成go.mod文件**

```shell
# 初始化一个test工程
go mod init test
```

#### (2) go mod 一些基本操作

```shell
# 添加工程依赖包，会加入到go.mod文件中的require中
go mod download github.com/mattn/go-sqlite3
# 根据go.mod文件处理依赖关系
go mod tidy
```

## 2. goframe

### 2.1. 安装配置

**安装gf命令行工具**

- goframe安装需要一个gf命令行工具

```shell
# 下载安装gf
wget -O gf https://github.com/gogf/gf-cli/releases/download/v1.16.3/gf_linux_amd64 && chmod +x gf && ./gf install
```

- 默认gf命令行工具不支持sqlite3，如果需要，上面安装完之后，自己编译一版sqlite3的gf工具
- 确保有gcc编译环境

```shell
# clone仓库
git clone https://github.com/gogf/gf-cli && cd gf-cli
# 设置环境变量
export CGO_ENABLED=1
# 将代码中的sqlite3依赖取消注释
vim command/gen/gen_dao.go
...
# 执行gf的编译命令，需要上述步骤先下载gf工具
# -a指定平台，可以编译下面几种平台
#       darwin    amd64,arm64
#       freebsd   386,amd64,arm
#       linux     386,amd64,arm,arm64,ppc64,ppc64le,mips,mipsle,mips64,mips64le
#       netbsd    386,amd64,arm
#       openbsd   386,amd64,arm
#       windows   386,amd64
gf build main.go -a amd64 -s linux --cgo
# 安装
cp bin/linux_amd64/gf /usr/local/bin/gf
```

**初始化**

- 如果需要使用sqlite3，需要在项目根目录执行

```shell
go mod download github.com/mattn/go-sqlite3
```

**代码生成**

- 根据`config.toml`生成数据库代码，这个比较方便

```shell
gf gen dao -c config/config.toml
```

### 2.2. 开发知识点

#### 2.2.1. orm时间维护功能

- orm的数据库更新操作会自动更新updatedAt、createdAt、deletedAt等字段
- 不想要更新字段需要加上`Unscoped()`

```go
db.Table("user").Unscoped().Data(g.Map{"name" : "john guo"}).Where("name", "john").Update()
```

### 2.2.2. 前后端字段对应

- gf中使用下面的方法可以将前端传入参数解析到struct的对应成员中

```go
// app/model/xxx.go
type TaskApiCreateReq struct {
	Content  string `json:"content" v:"required|length:1,100#任务内容不能为空|任务内容应当在:min到:max之间"`
	TaskType int    `json:"taskType"`
}
// app/api/xxx.go
func (a *task) Create(r *ghttp.Request) {
	var (
		data *model.TaskApiCreateReq
	)
	if err := r.Parse(&data); err != nil {
		response.JsonExit(r, 1, err.Error())
	}
	...
}
```

- 解析规则，会把前端传入的字段去除除了字母和数字的所有特殊字符，然后不区分大小写比较
- 下面的几个key都可以解析到上面的`data.Content`中

```json
{
	"Content": "xxx",
	"content": "xxx",
	"con_tent": "xxx",
	"conTent": "xxx"
}
```

# 六、好用的第三方库

## 1. uuid

```go
package main

import (
	"fmt"

	"github.com/google/uuid"
)

func main() {
	id := uuid.New()
	fmt.Printf("%s %s\n", id, id.Version().String())
}
```

**输出**

```
ab8d63ef-f0c4-a01d-a6ef-5f2c3efff5af VERSION_4
```

## 2. `github.com/makiuchi-d/gozxing` 二维码解析和生成

- `github.com/tuotoo/qrcode`没成功的，这个成功了

```go
package main

import (
	"bytes"
	"fmt"
	"image"
	"image/png"
	"io/ioutil"

	"github.com/makiuchi-d/gozxing"
	_ "github.com/makiuchi-d/gozxing/common"
	"github.com/makiuchi-d/gozxing/qrcode"
)

func parseQrcode(pngPath string) string {
	originByte, _ := ioutil.ReadFile(pngPath)
	originBuffer := bytes.NewBuffer(originByte)
	originImg, _, err := image.Decode(originBuffer)
	if err != nil {
		return err.Error()
	}
	fmt.Println(filename)

	// 解析二维码返回结果
	bmp, _ := gozxing.NewBinaryBitmapFromImage(originImg)
	qrReader := qrcode.NewQRCodeReader()
	result, err := qrReader.Decode(bmp, nil)
	if err != nil {
		return err.Error()
	}
	return result.GetText()
}
```

## 3. `golang.org/x/mobile` go开发android和ios

[gomobile使用笔记](/blogs/2022-05-24-gomobile)

# 七、实战

## 1. 搭建简单http服务器

### 1.1. 模板

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

type retJson struct {
	Code  int    `json:"code"`
	LLLL  string `json:"llll"`
	AAAA  string `json:"aaaa"`
	Token string `json:"token"`
}

func smsServerHandler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	fmt.Println(r.Form)
	fmt.Println("path", r.URL.Path)
	fmt.Println("scheme", r.URL.Scheme)

	var ret retJson
	ret.Code = 0
	ret.LLLL = "test"
	ret.AAAA = "stest"
	ret.Token = "a454as1bbvd5g5s15155"
	retBytes, _ := json.MarshalIndent(&ret, "", "    ")
	retStr := string(retBytes)
	fmt.Println(retStr)

	w.Header().Set("Content-Type", "application-json")
	fmt.Fprintf(w, retStr)
}

func main() {
	// 接口处理到函数
	http.HandleFunc("/", smsServerHandler)
	// 接口处理到目录，主要用于静态页面返回
	http.Handle("/", http.FileServer(http.Dir("template")))
	err := http.ListenAndServe(":7878", nil)
	if err != nil {
		log.Fatal("ListenAndServe failed, err: ", err)
	}
}
```

### 1.2. 静态页面路径返回

**最简单跟目录返回**

```go
package main

import (
	"log"
	"net/http"
)

func main() {
	// 接口处理到目录，主要用于静态页面返回
	http.Handle("/", http.FileServer(http.Dir("template")))
	err := http.ListenAndServe(":7878", nil)
	if err != nil {
		log.Fatal("ListenAndServe failed, err: ", err)
	}
}
```

**其他路径返回页面**

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 访问根转发到template
	if r.URL.Path == "/" {
		http.Redirect(w, r, "/template/", http.StatusFound)
		return
	}
	w.Write([]byte(r.URL.Path))
}

func main() {
	// 返回界面，将 /template/ 裁掉访问目录
	http.Handle("/template/", http.StripPrefix("/template/", http.FileServer(http.Dir("./template"))))
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

### 1.3. 上传文件

```go
package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
)

func uploadHandler(w http.ResponseWriter, r *http.Request) {
	// 获取表单的file字段
	file, handler, err := r.FormFile("file")
	if err != nil {
		fmt.Println("upload failed, err:", err)
		w.Write([]byte("upload success"))
		return
	}
	defer file.Close()

	// 本地创建文件
	f, err := os.Create("./upload_dir/" + handler.Filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	// 文件保存
	_, err = io.Copy(f, file)
	if err != nil {
		panic(err)
	}
	w.Write([]byte("upload success"))
}

func main() {
	http.Handle("/", http.FileServer(http.Dir("template")))
	// 设置接口处理文件传输
	http.HandleFunc("/uploadfile", uploadHandler)
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}

```

### 1.4. 302跳转

**简单跳转**

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func main() {
	// 直接跳转
	http.HandleFunc("/", http.RedirectHandler("http://1.1.1.1", http.StatusFound))

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

**特定目录跳转**

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 访问根转发到template
	if r.URL.Path == "/" {
		http.Redirect(w, r, "/template/", http.StatusFound)
		return
	}
	w.Write([]byte(r.URL.Path))
}

func main() {
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

### 1.5. 代理转发

- 定义tr忽略证书错误

```go
package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 访问根转发到template
	if r.URL.Path == "/" {
		http.Redirect(w, r, "/template/", http.StatusFound)
		return
	}

	// 请求转发给另一个url
	remote, err := url.Parse("https://1.1.1.1")
	if err != nil {
		log.Fatalln("serverAddr is invalid")
	}
	proxy := httputil.NewSingleHostReverseProxy(remote)

	// 忽略证书错误
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	proxy.Transport = tr

	proxy.ServeHTTP(w, r)
}

func main() {
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

### 1.4. 处理post的body数据

- json数据存在body里面
**<font color="red">`r.Body`只能读取一次，读完就会关闭，需要再次读取需要加上下面注释说明的代码</font>**

```go
package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	var body []byte
	if r.Body != nil {
		body, err = ioutil.ReadAll(r.Body)
		if err != nil {
			fmt.Println(err)
			return
		}
	}

	// 如果body想要多次读取需要加上下面的语句，重新申请一个readerCloser
	r.Body = ioutil.NopCloser(bytes.NewReader(body))
}

func main() {
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

# 踩坑记
