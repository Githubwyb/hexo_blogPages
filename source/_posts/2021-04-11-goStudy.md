---
title: go语言学习
date: 2021-04-11 02:06:33
tags:
categories: [Program, Web]
---

# 一、前言

## 环境

```shell
=> go version
go version go1.16.4 linux/amd64
```

# 二、语法相关

## 1. 基本类型

### 1.1. 去除变量未定义提示

```go
_ = varA
```

### 1.2. 类型及转换

#### int

```go
// 转string
fmt.Sprint(123)
```

#### float32 float64

```go
// 转int
var f float32 = 1
var a int = int(f)
```

#### string

```go
// 转[]byte
var jsonStr string
jsonByte := []byte(jsonStr)

// 转byte
testByte := jsonStr[0]
```

**单引号，双引号，反引号的区别**

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Printf("%c %d\n", 'a', 'a')
    fmt.Printf("a\n")
    fmt.Printf("%s\n", `a\n`)
}
```

输出

```shell
a 97
a
a\n
```

**字符串截取**

```go
outStr := "abcdefg"
fmt.Println(outStr[0])		// 97，被识别成byte打印了
fmt.Println(outStr[:3])		// abc
fmt.Println(outStr[3:5])	// de
fmt.Println(outStr[5:])		// fg

fmt.Println(outStr[:-2])	// 不支持，索引仅支持正数
```

**遍历**

```golang
s := "abc"
for i := range(s) {
	fmt.Println(i)
}
/* 输出
0
1
2
*/

for i, v := range(s) {
	fmt.Println(i, byte(v))
}
/* 输出
0 a
1 b
2 c
*/
```

#### []byte

```go
// 转string
data := []byte("aaa")
str := string(data)
```

#### interface

**类型判断**

类型断言

```go
var f interface{}

if _, ok = f.(string); !ok {
	fmt.Println("f type is not string")
}
```

switch类型判断

```go
var f interface{}

switch(f.(type)) {
case string:
	fmt.Println("f type is string")
	break

case int:
	fmt.Println("f type is int")
	break

default:
	fmt.Println("f type is unknown")
	break
}
```

## 2. map

### 2.1. 一些基本操作

```go
/****** map初始化 ******/
xxxMap := make(map[string]interface{})

/****** 判断map是否存在key ******/
if _, ok := xxxMap[key]; ok {
    // 存在key
}

/****** 遍历map ******/
for key, value := range xxxMap {
    // 操作map
}
```

### 注意事项

- `var xxx map[string]interface{}`定义的xxx是一个空指针，没有指向任何地址，不能进行赋值
- 初始化map需要使用make

## 3. array

### 3.1. 一些基本操作

```go
/****** array初始化 ******/
arr0 := [...]int{0, 1}
arr1 := [...]int{0, 1}

/****** 遍历 ******/
for _, v := range arr0 {
	fmt.Println(v)
}
```

## 4. slice

### 4.1. 一些基本操作

```go
/****** slice初始化 ******/
s0 := []int{0, 1}
s1 := []int{0, 1}
s2 := make([]int, 5)		// len 5, cap 5
s3 := make([]int, 0, 10)	// len 0, cap 10

/****** slice添加元素 ******/
// go对append有处理，如果赋值给原切片，且切片空间足够，不会新申请内存
// 赋值给原切片，空间不够，会申请cap的两倍大小空间
// 如果赋值给不同切片，会新申请内存，不会更改原切片
s0 = append(s0, 2)
s0 = append(s0, 3, 4)
// 切片合并，其中s1...意味着将s1拆分成元素传入append
// 相当于调用添加多个元素
s0 = append(s0, s1...)

/****** 遍历 ******/
for _, v := range s0 {
	fmt.Println(v)
}
```

## 5. 流程控制语句

### 5.1. for 循环

```go
// 死循环
for {
	...
}
// for i 形式
for i := 0; i < len(a); i++ {
	...
}
// 遍历
for _, v := range(arr) {
	...
}
// do while
for {
	...
	if expression {
		break
	}
}
// while
for {
	if expression {
		break
	}
	...
}
```

## 6. 函数

### 6.1. 定义和返回值

```go
// 正常定义
func test(a int) int {
	return a + 1
}
// 多返回值
func test(a int) (int, int) {
	return a+1, a-1
}
// nil 返回初始化定义，仅对slice和map生效
func test(a int) []int {
	return nil	// 相当于return []int{}
}
// 返回值提前声明
func test(a int) (result int) {
	result = a + 1
	return
}
```

### 6.2. 值传递

#### (1) go函数都是值传递

```go
func changeDatas(intData int, strData string, arrData [3]int) {
	intData += 2
	strData += "bbb"
	arrData[0] = 999
}

func main() {
	intData := 1
	strData := "aaa"
	arrData := [...]int{1, 2, 3}
	fmt.Println(intData, strData, arrData)
	changeDatas(intData, strData, arrData)
	fmt.Println(intData, strData, arrData)
}
```

输出

```
1 aaa [1 2 3]
1 aaa [1 2 3]
```

#### (2) slice、map、channel都是引用类型，即便是值传递，结构内部还是指向原来的引用对象，所以函数体内可以直接修改元素。

- 也就是传递了一个结构体，结构体里面有一个指针指向数据段，所以可以直接修改元素

<img src="2022-02-18-01.jpg">

```go
func changeDatas(sliceData []int, mapData map[string]int) {
	sliceData[0] = 999
	mapData["test"] = 123
}

func main() {
	sliceData := []int{1, 2, 3}
	mapData := make(map[string]int)
	fmt.Println(sliceData, mapData)
	changeDatas(sliceData, mapData)
	fmt.Println(sliceData, mapData)
}
```

输出

```
[1 2 3] map[]
[999 2 3] map[test:123]
```

#### (3) 如果slice触发扩容，data会指向新的底层数组，而不指向外部的底层数组了。所以之后再修改slice，不会对外部的slice造成影响。

```go
func changeDatas(sliceData []int) {
	sliceData[0] = 999                   // 修改了外部变量
	sliceData = append(sliceData, 12345) // 扩容重新赋值data
	sliceData[1] = 777                   // 无法修改外部变量，修改的是重新建的data
}

func main() {
	sliceData := []int{1, 2, 3, 4}
	fmt.Println(sliceData)
	changeDatas(sliceData)
	fmt.Println(sliceData)
}
```

结果

```
[1 2 3 4]
[999 2 3 4]
```


## 7. 组合赋值

```go
a, b := 1+1, 2+2
```

## 8. i++、i--

```go
i++		// 理解成 i+=1
j=i++	// error，i++是i+=1，是语句，非表达式，不能赋值
++i		// error，不存在++i
```

## 9. const & iota

### 9.1. itoa

参考[golang const 内itoa 用法详解及优劣分析](https://www.jianshu.com/p/aad37a6c81a2)

#### (1) 每次 const 出现时，都会让 iota 初始化为0

```golang
const a = iota // a = 0
const (
  b = iota     // b = 0
  c            // c = 1
)
```

#### (2) 自定义类型

自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。

```golang
type Newtype int

const (
    T1 Newtype = iota // 0
    T2                // 1
    T3                // 2
    T4                // 3
)
```

#### (3) 可跳过的值

```golang
type AudioOutput int

const (
    OutMute AudioOutput = iota // 0
    OutMono                    // 1
    OutStereo                  // 2
    _
    _
    OutSurround                // 5
)
```

#### (4) 位掩码表达式

```golang
type Allergen int

const (
    IgEggs Allergen = 1 << iota // 1 << 0 which is 00000001
    IgChocolate                         // 1 << 1 which is 00000010
    IgNuts                              // 1 << 2 which is 00000100
    IgStrawberries                      // 1 << 3 which is 00001000
    IgShellfish                         // 1 << 4 which is 00010000
)
```

#### (5) 定义数量级

```golang
type ByteSize float64

const (
    _           = iota                   // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)       // 1 << (10*1)
    MB                                   // 1 << (10*2)
    GB                                   // 1 << (10*3)
    TB                                   // 1 << (10*4)
    PB                                   // 1 << (10*5)
    EB                                   // 1 << (10*6)
    ZB                                   // 1 << (10*7)
    YB                                   // 1 << (10*8)
)
```

#### (6) 定义在一行的情况

跟普通形式 没什么不同
iota 在下一行增长，而不是立即取得它的引用。

```golang
const (
	Apple, Banana     = iota + 1, iota + 2 // 0+1, 0+2
	Cherimoya, Durian                      // 1+1, 1+2
	Elderberry, Fig                        // 2+1, 2+2
)

/*
1, 2
2, 3
3, 4
*/
```

#### (7) 中间插队

中间插队时，iota 会被覆盖掉 不再继续自增。但是用另一个 iota 接一下，又会继续自增。
示例如下，中间插入了5、3和6，3下面有itoa接，6没有。

```golang
const(
    a = iota		// 0	itoa = 0
    b = 5			// 5	itoa = 1
    c = 3			// 3	itoa = 2
    d = iota		// 3	itoa = 3
    e = 6			// 6
    f				// 6
    g				// 6
)
```

# 三、标准库

## 1. encoding/json

### 1.1. 一些基本操作

```go
package main

import (
	"encoding/json"
)

func main() {
	/****** 将json字符串序列化成go对象 ******/
	// 先marshal在unmarshal可以让一个未知的interface确定内部类型
	// Unmarshal可以将一个json字符串解析到一个特定的格式下
	// json.Unmarshal会将数字解析成float64
	json.Unmarshal(jsonBytes, &target)

	/****** 将go对象转成json字符串 ******/
	var f interface{}
	jsonBytes, err := json.Marshal(&f)
	// 格式化的字符串，第二个是前缀，第三个是缩进符号
	jsonIndentBytes, err := json.MarshalIndent(&f, "", "    ")
}
```

### 1.2. key排序转json

- go默认对`map[string]interface{}`转json按照key升序转化
- 想要对key排序只能通过结构体的方式，转json会按照结构体的顺序转化
- 为空的key不想输出，可以加上`omitempty`

```go
type outT struct {
	Type string `json:"type,omitempty"`
	Name string `json:"name,omitempty"`
}

func main() {
	var f outT
	str, _ := json.Marshal(&f)	// {}
}
```

### 注意事项

- 数字类型在Unmarshal之后会转成float64，只能断言为float64

## 2. testing 单测

```go
package service

import (
	"encoding/json"
	"errors"
	"reflect"
	"sort"
	"testing"

	"github.com/gin-gonic/gin"

	. "github.com/agiledragon/gomonkey"
	. "github.com/smartystreets/goconvey/convey"
)

func TestFunc(t *testing.T) {
	sess := session.Session{}
	var s *session.Session

    // hook类的成员函数Commit
	patch := ApplyMethod(reflect.TypeOf(s), "Commit", func(_ *session.Session) error { return nil })
	defer patch.Reset()

    // 使用Convey包裹，可以按照分组测试
	Convey("TestFunc", t, func() {
		Convey("正常流程", func() {
			Convey("插入单个数据", func() {
				sess.New()
                ...
                // So确定
				So(tmp, ShouldResemble, []string{"aaa"})
			})
		})
		Convey("异常流程", func() {
			Convey("GetSessionData出错", func() {
				sess.New()
				...
				patch1 := ApplyMethod(reflect.TypeOf(s), "GetSessionData",
					func(_ *session.Session, _ string) (interface{}, error) {
						return nil, errors.New("testErr")
					})
				...
				So(tmp, ShouldResemble, []string{})
				patch1.Reset()
				...
				So(tmp, ShouldResemble, []string{"bbb"})
			})
		})
	})
}

```

## 3. flag 控制台参数解析

### 3.1. 获取命令行参数

```go
package main

import (
	"fmt"
	"flag"
)

func main() {
	// 在使用前先调用此函数解析参数，不然会返回空
	flag.Parse()
	// 打印第一个参数
	fmt.Println(flag.Arg(0))
	// 打印所有非flag的参数
	fmt.Println(flag.Args())
	// 打印参数个数
	fmt.Println(flag.NArg())
}
```

输出

```shell
=> go run main.go a -a -b -asdfsaf cccc
a
[a -a -b -asdfsaf ccc]
5
```

## 4. path/filepath 目录操作库

### 4.1. 遍历目录下所有文件和目录，类似 `find xxx`

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "path/filepath"
)

func getFileList(path string) {
    err := filepath.Walk(path, func(path string, f os.FileInfo, err error) error {
        if f == nil {
            return err
        }
        if f.IsDir() {
            return nil
        }
        println(path)
        return nil
    })
    if err != nil {
        fmt.Printf("filepath.Walk() return %v\n", err)
    }
}

func main() {
    flag.Parse()
	var root string
    root = flag.Arg(0)
    getFileList(root)
}
```

输出

```shell
=> go run main.go .
go.mod
main.go
=> go run main.go ./
go.mod
main.go
=> go run main.go ../
../test/go.mod
../test/main.go
=> go run main.go /path/to/test
/path/to/test/go.mod
/path/to/test/main.go
```

## 5. os/exec 命令行调用

### 5.1. 阻塞式等待返回，并输出stdout

```go
package main

import (
    "bytes"
    "fmt"
    "os/exec"
)

func execShell(s string) (string, error) {
    cmd := exec.Command("/bin/bash", "-c", s)

    var out bytes.Buffer
    cmd.Stdout = &out

    err := cmd.Run()
    if err != nil {
        fmt.Printf("%v\n", err)
    }

    return out.String(), err
}

func main() {
    fmt.Println(execShell("ls /"))
}
```

## 6. net/http 网络请求库

### 6.1. 发送post请求

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func main() {
	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
    if err != nil {
        fmt.Println(err)
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(string(body))
}
```

### 6.2. 忽略https的证书错误

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
    "crypto/tls"
)

func main() {
	http.DefaultClient.Transport = &http.Transport{
        TLSClientConfig: &tls.Config{
            InsecureSkipVerify: true,
        },
    }

	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
	...
}
```

### 6.3. 搭建简单http服务器

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

type retJson struct {
	Code  int    `json:"code"`
	LLLL  string `json:"llll"`
	AAAA  string `json:"aaaa"`
	Token string `json:"token"`
}

func smsServerHandler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	fmt.Println(r.Form)
	fmt.Println("path", r.URL.Path)
	fmt.Println("scheme", r.URL.Scheme)

	var ret retJson
	ret.Code = 0
	ret.LLLL = "test"
	ret.AAAA = "stest"
	ret.Token = "a454as1bbvd5g5s15155"
	retBytes, _ := json.MarshalIndent(&ret, "", "    ")
	retStr := string(retBytes)
	fmt.Println(retStr)

	w.Header().Set("Content-Type", "application-json")
	fmt.Fprintf(w, retStr)
}

func main() {
	http.HandleFunc("/", smsServerHandler)
	err := http.ListenAndServe(":7878", nil)
	if err != nil {
		log.Fatal("ListenAndServe failed, err: ", err)
	}
}
```

## 7. strings 字符串操作库

### 7.1. 字符串替换

```go
package main

import (
	"strings"
)

func main() {
	outStr := '{"a":"123"}'
	// 将json中的双引号全部替换为单引号
	outStr = strings.ReplaceAll(outStr, `"`, `'`)
}
```

### 7.2. 裁剪两端字符串

- 只能裁剪两端的字符串，中间的不会裁剪

```go
outStr := "abffffffffabfffffffab"
outStr = strings.Trim(outStr, "ab")		// ffffffffabfffffff
```

### 7.3. 字符串分割

**Split**

- 根据某字符串分割

```go
arr := strings.Split("a,b,c", ",")	// [a b c]
```

**Fields**

- 根据空格分割，多个空格视为一个

```go
arr := strings.Fields("a b  c   d") // [a b c d]
```

## 8. encoding/hex 十六进制操作库

### 8.1. 将十六进制字符串转成数组

```go
arr, err := hex.DecodeString("aabbcc")	// [170 187 204]
```

## 9. io/ioutil io操作

### 9.1. 文件读取

```go
contentBytes, err := ioutil.ReadFile("/a/b/c.txt")
```

## 10. os 系统操作

### 10.1. 判断目录是否存在

```go
_, err := os.Stat("./")
if err != nil && os.IsNotExist(err) {
	// 目录不存在
}
```

## 11. stronv

```go
package main
import (
    "strconv"
    "fmt"
)
func main() {
    // 使用ParseFloat解析浮点数，64是说明使用多少位
    // 精度来解析
    f, _ := strconv.ParseFloat("1.234", 64)
    fmt.Println(f)

    // 对于ParseInt函数，0 表示从字符串推断整型进制，
    // 则表示返回结果的位数
    i, _ := strconv.ParseInt("123", 0, 64)
    fmt.Println(i)

    // ParseInt能够解析出16进制的数字
    d, _ := strconv.ParseInt("0x1c8", 0, 64)
    fmt.Println(d)

    // 还可以使用ParseUint函数
    u, _ := strconv.ParseUint("789", 0, 64)
    fmt.Println(u)

    // Atoi是解析10进制整型的快捷方法
    k, _ := strconv.Atoi("135")
    fmt.Println(k)

    // 解析函数在遇到无法解析的输入时，会返回错误
    _, e := strconv.Atoi("wat")
    fmt.Println(e)
}
```

# 四、框架

## 1. 工程知识

### 1.1. go.mod

- `go.mod`是go工程用来管理包使用的，类似于nodejs的`package.json`文件

#### (1) 创建新工程

**1. 先生成go.mod文件**

```shell
# 初始化一个test工程
go mod init test
```

#### (2) go mod 一些基本操作

```shell
# 添加工程依赖包，会加入到go.mod文件中的require中
go mod download github.com/mattn/go-sqlite3
# 根据go.mod文件处理依赖关系
go mod tidy
```

## 2. goframe

### 2.1. 安装配置

**安装gf命令行工具**

- goframe安装需要一个gf命令行工具

```shell
# 下载安装gf
wget -O gf https://github.com/gogf/gf-cli/releases/download/v1.16.3/gf_linux_amd64 && chmod +x gf && ./gf install
```

- 默认gf命令行工具不支持sqlite3，如果需要，上面安装完之后，自己编译一版sqlite3的gf工具
- 确保有gcc编译环境

```shell
# clone仓库
git clone https://github.com/gogf/gf-cli && cd gf-cli
# 设置环境变量
export CGO_ENABLED=1
# 将代码中的sqlite3依赖取消注释
vim command/gen/gen_dao.go
...
# 执行gf的编译命令，需要上述步骤先下载gf工具
# -a指定平台，可以编译下面几种平台
#       darwin    amd64,arm64
#       freebsd   386,amd64,arm
#       linux     386,amd64,arm,arm64,ppc64,ppc64le,mips,mipsle,mips64,mips64le
#       netbsd    386,amd64,arm
#       openbsd   386,amd64,arm
#       windows   386,amd64
gf build main.go -a amd64 -s linux --cgo
# 安装
cp bin/linux_amd64/gf /usr/local/bin/gf
```

**初始化**

- 如果需要使用sqlite3，需要在项目根目录执行

```shell
go mod download github.com/mattn/go-sqlite3
```

**代码生成**

- 根据`config.toml`生成数据库代码，这个比较方便

```shell
gf gen dao -c config/config.toml
```

### 2.2. 开发知识点

#### 2.2.1. orm时间维护功能

- orm的数据库更新操作会自动更新updatedAt、createdAt、deletedAt等字段
- 不想要更新字段需要加上`Unscoped()`

```go
db.Table("user").Unscoped().Data(g.Map{"name" : "john guo"}).Where("name", "john").Update()
```

### 2.2.2. 前后端字段对应

- gf中使用下面的方法可以将前端传入参数解析到struct的对应成员中

```go
// app/model/xxx.go
type TaskApiCreateReq struct {
	Content  string `json:"content" v:"required|length:1,100#任务内容不能为空|任务内容应当在:min到:max之间"`
	TaskType int    `json:"taskType"`
}
// app/api/xxx.go
func (a *task) Create(r *ghttp.Request) {
	var (
		data *model.TaskApiCreateReq
	)
	if err := r.Parse(&data); err != nil {
		response.JsonExit(r, 1, err.Error())
	}
	...
}
```

- 解析规则，会把前端传入的字段去除除了字母和数字的所有特殊字符，然后不区分大小写比较
- 下面的几个key都可以解析到上面的`data.Content`中

```json
{
	"Content": "xxx",
	"content": "xxx",
	"con_tent": "xxx",
	"conTent": "xxx"
}
```

### 踩坑记
