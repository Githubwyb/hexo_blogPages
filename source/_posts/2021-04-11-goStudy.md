---
title: go语言学习
date: 2021-04-11 02:06:33
tags:
categories: [Program, Web]
top: 100
---

# 一、前言

## 1. 环境

```shell
=> go version
go version go1.16.4 linux/amd64
```

## 2. 安装gvm版本管理工具

### 2.1. 安装

```shell
wget https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer
bash gvm-installer
```

- 默认生效到`~/.bashrc`，生效到zsh需要将下面一句话加到`.zshrc`最后

```shell
[[ -s "/home/wangyubo/.gvm/scripts/gvm" ]] && source "/home/wangyubo/.gvm/scripts/gvm"
```

### 2.2. 使用

```shell
# 查看可安装的版本
gvm listall
# 查看当前版本
gvm list
# 安装一个版本
gvm install go1.18.3
# 使用一个版本，回归默认就是 gvm use system
gvm use go1.18.3
```

# 二、语法相关

## 1. 基本类型

### 1.1. 去除变量未定义提示

```go
_ = varA
```

#### 1.2. int

##### 1) 大小

- 32位下int为4个字节，64位下int为8个字节

##### 2) 类型转换

```go
// 转string
fmt.Sprint(123)
```

### 1.2. 类型转换

#### float32 float64

```go
// 转int
var f float32 = 1
var a int = int(f)
```

#### []byte

```go
// 转string
data := []byte("aaa")
str := string(data)
```

#### interface

**类型判断**

类型断言

```go
var f interface{}

if _, ok = f.(string); !ok {
	fmt.Println("f type is not string")
}
```

switch类型判断

```go
var f interface{}

switch(f.(type)) {
case string:
	fmt.Println("f type is string")

case int:
	fmt.Println("f type is int")

default:
	fmt.Println("f type is unknown")
}
```

### 1.2. string

#### 1) 转换

```go
// 转[]byte
var jsonStr string
jsonByte := []byte(jsonStr)

// 转byte
testByte := jsonStr[0]

// 转uint64
// The bitSize argument specifies the integer type
// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
// correspond to uint, uint8, uint16, uint32, and uint64.
var num uint64
num, err := strconv.ParseUint("1234", 10, 64)

// 转int64
// The bitSize argument specifies the integer type
// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
// correspond to int, int8, int16, int32, and int64.
var num uint64
num, err := strconv.ParseInt("1234", 10, 64)
```

#### 2) 单引号，双引号，反引号的区别

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Printf("%c %d\n", 'a', 'a')	// 单引号代表byte
    fmt.Printf("a\n")				// 双引号可以输入转义字符
    fmt.Printf("%s\n", `a\n`)		// 反引号会忽略转义
}
```

输出

```shell
a 97
a
a\n
```

#### 2) 字符串截取

```go
outStr := "abcdefg"
fmt.Println(outStr[0])		// 97，被识别成byte打印了
fmt.Println(outStr[:3])		// abc
fmt.Println(outStr[3:5])	// de
fmt.Println(outStr[5:])		// fg

fmt.Println(outStr[:-2])	// 不支持，索引仅支持正数
```

#### 3) 遍历

```go
s := "abc"
for i := range(s) {
	fmt.Println(i)
}
/* 输出
0
1
2
*/

for i, v := range(s) {
	fmt.Println(i, byte(v))
}
/* 输出
0 a
1 b
2 c
*/
```

#### 4) 修改

- string类型里面的元素是不可变的，除非赋值一个新的string
- 如果想要修改string中某一个元素，相当于拷贝了两次

```go
a := "abc"
tmp := []byte(a)	// 做了一次拷贝
tmp[0] = 'z'
fmt.Println(a)		// abc
a = string(tmp)		// 又拷贝了一次
fmt.Println(a)		// zbc
```

### 1.3. slice

#### 1) 一些基本操作

```go
/****** slice初始化 ******/
s0 := []int{0, 1}
s1 := []int{0, 1}
s2 := make([]int, 5)		// len 5, cap 5
s3 := make([]int, 0, 10)	// len 0, cap 10

/****** slice添加元素 ******/
// go对append有处理，如果赋值给原切片，且切片空间足够，不会新申请内存
// 赋值给原切片，空间不够，会申请cap的两倍大小空间
// 如果赋值给不同切片，会新申请内存，不会更改原切片
s0 = append(s0, 2)
s0 = append(s0, 3, 4)
// 切片合并，其中s1...意味着将s1拆分成元素传入append
// 相当于调用添加多个元素
s0 = append(s0, s1...)

/****** slice删除元素 ******/
s0 = s0[2:]				// 截取2到末尾，删除前两个元素
s1 = s1[:len(s1)-2]		// 开头到倒数第3个元素，删除后两个元素
s0 = s0[:0]				// 清理slice，不改变cap

/****** 遍历 ******/
for _, v := range s0 {
	fmt.Println(v)
}
```

### 1.4. any

- 在go的底层，any就是`interface{}`，只是因为长度太长，换个名字

#### 2) 底层操作的优化

##### (1) 新增的优化

```go
// go对append有处理，如果赋值给原切片，且切片空间足够，不会新申请内存
// 赋值给原切片，空间不够，会申请cap的两倍大小空间
// 如果赋值给不同切片，会新申请内存，不会更改原切片
s0 = append(s0, 2)
```

##### (2) 删除的优化

```go
testArr := []int{2, 7, 4, 9, 1, 4, 8}
fmt.Println(cap(testArr), testArr) // 7 [2 7 4 9 1 4 8]
testArr = testArr[:len(testArr)-1]
fmt.Println(cap(testArr), testArr) // 7 [2 7 4 9 1 4]
testArr = testArr[1:]
fmt.Println(cap(testArr), testArr) // 6 [7 4 9 1 4]
testArr = testArr[:0]              // 清理slice，不改变容量
fmt.Println(cap(testArr), testArr) // 6 []
```

- 从打印猜测，如果删除slice末尾元素赋值给同一个slice，不会改变cap，直接把len减1
- 如果删除slice的头部元素，会直接把数组data段的首地址后移，cap会减少

#### 3) 动态初始化二维数组（矩阵）

- 矩阵的长宽不确定，构建的时候就需要一个一个进行构建，类似下面这样

```go
seen := make([][]bool, r)
for i := 0; i < r; i++ {
	seen[i] = make([]bool, c)
}
```

## 2. map

- 底层使用哈希map实现而非红黑树

### 2.1. 一些基本操作

```go
/****** map初始化 ******/
xxxMap := make(map[string]interface{})
check := map[byte]byte{
	')': '(',
	'[': ']',
	'{': '}',
}

/****** 判断map是否存在key ******/
if _, ok := xxxMap[key]; ok {
    // 存在key
}

/****** 遍历map ******/
// key, value
for key, value := range xxxMap {
    // 操作map
}
// 只要key
for key := range xxxMap {
	// do something
}
```

### 2.2. map取不存在的值

- 对map取值可以获取一个返回值也可以获取两个返回值用于判断是否存在
- 如果不存在采用一个返回值会返回对应value的类型的默认值

```go
tmpMap := make(map[int]int)
tmpMap[1] = 2
v := tmpMap[2]	// v = 0
```

### 注意事项

- `var xxx map[string]interface{}`定义的xxx是一个空指针，没有指向任何地址，不能进行赋值
- 初始化map需要使用make

## 3. array

### 3.1. 一些基本操作

```go
/****** array初始化 ******/
arr0 := [...]int{0, 1}
arr1 := [...]int{0, 1}

/****** 遍历 ******/
for _, v := range arr0 {
	fmt.Println(v)
}
```

## 5. 流程控制语句

### 5.1. for 循环

```go
// 死循环
for {
	...
}
// for i 形式
for i := 0; i < len(a); i++ {
	...
}
// 遍历
for _, v := range(arr) {
	...
}
// do while
for {
	...
	if expression {
		break
	}
}
// while
for {
	if expression {
		break
	}
	...
}
```

### 5.2. switch

- case多条件写成逗号形式，c那样的写法不适用

```go
	switch v.key {
	case "Maker":
		...
	case "OS":
		...
	// 多条件判断
	case "linuxOS", "linuxKernel", "linuxArch":
		...
	}
```

## 6. 函数

### 6.1. 定义和返回值

```go
// 正常定义
func test(a int) int {
	return a + 1
}
// 多返回值
func test(a int) (int, int) {
	return a+1, a-1
}
// nil 返回初始化定义，仅对slice和map生效
func test(a int) []int {
	return nil	// 相当于return []int{}
}
// 返回值提前声明
func test(a int) (result int) {
	result = a + 1
	return
}
```

### 6.2. 值传递

#### (1) go函数都是值传递

```go
func changeDatas(intData int, strData string, arrData [3]int) {
	intData += 2
	strData += "bbb"
	arrData[0] = 999
}

func main() {
	intData := 1
	strData := "aaa"
	arrData := [...]int{1, 2, 3}
	fmt.Println(intData, strData, arrData)
	changeDatas(intData, strData, arrData)
	fmt.Println(intData, strData, arrData)
}
```

输出

```
1 aaa [1 2 3]
1 aaa [1 2 3]
```

#### (2) slice、map、channel类型的看似引用传递的解释

##### slice

- slice本质是一个结构体，内部包含三要素：长度、容量、数据首地址
- 所以传递的也是这三个值，数据内容改变改的是地址里面的内容，外部可见，但是改了长度和容量，外部就不会变

<img src="2022-02-18-01.jpg">

```go
func changeDatas(sliceData []int, mapData map[string]int) {
	sliceData[0] = 999
	mapData["test"] = 123
}

func main() {
	sliceData := []int{1, 2, 3}
	mapData := make(map[string]int)
	fmt.Println(sliceData, mapData)
	changeDatas(sliceData, mapData)
	fmt.Println(sliceData, mapData)
}
```

输出

```
[1 2 3] map[]
[999 2 3] map[test:123]
```

##### map和channel都是指针

- 本质上map和channel都是指针，所以改动外部都可见

## 7. 组合赋值

- 组合赋值会先将值取出再赋值给前面的变量，所以go不需要swap方法

```go
a, b := 1+1, 2+2
// 交换两个元素的值
a, b = b, a
```

## 8. i++、i--

```go
i++		// 理解成 i+=1
j=i++	// error，i++是i+=1，是语句，非表达式，不能赋值
++i		// error，不存在++i
```

## 9. const & iota

### 9.1. itoa

参考[golang const 内itoa 用法详解及优劣分析](https://www.jianshu.com/p/aad37a6c81a2)

#### (1) 每次 const 出现时，都会让 iota 初始化为0

```go
const a = iota // a = 0
const (
  b = iota     // b = 0
  c            // c = 1
)
```

#### (2) 自定义类型

自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。

```go
type Newtype int

const (
    T1 Newtype = iota // 0
    T2                // 1
    T3                // 2
    T4                // 3
)
```

#### (3) 可跳过的值

```go
type AudioOutput int

const (
    OutMute AudioOutput = iota // 0
    OutMono                    // 1
    OutStereo                  // 2
    _
    _
    OutSurround                // 5
)
```

#### (4) 位掩码表达式

```go
type Allergen int

const (
    IgEggs Allergen = 1 << iota // 1 << 0 which is 00000001
    IgChocolate                         // 1 << 1 which is 00000010
    IgNuts                              // 1 << 2 which is 00000100
    IgStrawberries                      // 1 << 3 which is 00001000
    IgShellfish                         // 1 << 4 which is 00010000
)
```

#### (5) 定义数量级

```go
type ByteSize float64

const (
    _           = iota                   // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)       // 1 << (10*1)
    MB                                   // 1 << (10*2)
    GB                                   // 1 << (10*3)
    TB                                   // 1 << (10*4)
    PB                                   // 1 << (10*5)
    EB                                   // 1 << (10*6)
    ZB                                   // 1 << (10*7)
    YB                                   // 1 << (10*8)
)
```

#### (6) 定义在一行的情况

- 跟普通形式 没什么不同
- iota 在下一行增长，而不是立即取得它的引用。

```go
const (
	Apple, Banana     = iota + 1, iota + 2 // 0+1, 0+2
	Cherimoya, Durian                      // 1+1, 1+2
	Elderberry, Fig                        // 2+1, 2+2
)

/*
1, 2
2, 3
3, 4
*/
```

#### (7) 中间插队

中间插队时，iota 会被覆盖掉 不再继续自增。但是用另一个 iota 接一下，又会继续自增。
示例如下，中间插入了5、3和6，3下面有itoa接，6没有。

```go
const(
    a = iota		// 0	itoa = 0
    b = 5			// 5	itoa = 1
    c = 3			// 3	itoa = 2
    d = iota		// 3	itoa = 3
    e = 6			// 6
    f				// 6
    g				// 6
)
```

## 10. 并发

### 10.1. 基础概念

- [go调度详解](https://zhuanlan.zhihu.com/p/27056944)

**和线程的区别**

- OS线程（操作系统线程）一本都有固定的栈内存（通常为2MB）
- 一个 goroutine 的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine 的栈不是固定的，他可以按需增大和缩小，grorutine的栈大小限制可以达到1GB，但极少情况下会到1GB。所以在Go语言中一次创建十万左右的 grorutine 也是可以的。

**和线程的关系**

- 一个操作系统线程对应用户态多个goroutine。
- go程序可以同时使用多个操作系统线程。
- goroutine和OS线程是多对多的关系，即m:n。

**其他**

- 1.5版本之前，go仅占用一个核执行
- 1.5之后，默认使用所有核

### 10.2. `sync.WaitGroup` 等待退出

```go
package main

import (
    "fmt"
    "sync"
)

var wg sync.WaitGroup

func hello(i int) {
    fmt.Println("Hello", i)
    wg.Done()
}

func main() {
    fmt.Println("Hello world, main")
    for i := 1; i < 1000; i++ {
        wg.Add(1)
        go hello(i)
    }
    wg.Wait()
}
```

### 10.3. `runtime.GOMAXPROCS(i int)` 限定占用核心数

- go可以设定goroutine占用的核心数

```go
package main

import (
    "fmt"
    "sync"
	"runtime"
)

var wg sync.WaitGroup

func hello(i int) {
    fmt.Println("Hello", i)
    wg.Done()
}

func main() {
	runtime.GOMAXPROCS(1)
    fmt.Println("Hello world, main")
    for i := 1; i < 1000; i++ {
        wg.Add(1)
        go hello(i)
    }
    wg.Wait()
}
```

### 10.4. 互斥锁

```go

```

### 10.5. channel 管道

#### 1) 缓冲与无缓冲

- 无缓冲channel只负责数据的流转不负责存储数据，所以发送前必须有数据的接收者，否则发送会阻塞
- 缓冲channel可以储存部分数据，发送在缓冲区满之前可以发完继续运行

## 11. 面向对象编程

### 11.1. 属性和方法

- go中使用结构体可以代表类
- 定义接受者代表方法

```go
package main

import (
    "fmt"
)

// Rectangle define class
type Rectangle struct {
    X int
    Y int
}

// Area define method
func (r *Rectangle) Area() int {
    return r.X * r.Y
}

func main() {
    rec := Rectangle{
        X: 5,
        Y: 10,
    }
    fmt.Println(rec.Area())
}
```

### 11.2. 访问权限

- 首字母大小写可以控制访问权限
- 不过小写对整个package都可以访问，外部不可以访问

### 11.3. 继承

- 结构体里面直接定义另一个结构体就可以实现继承
- 但是初始化不能直接初始化父类的属性
- 同一个包内，大小写都可以访问到

```go
package main

import "fmt"

// Rectangle define class
type Rectangle struct {
    x int
    Y int
}

// Area define method
func (r *Rectangle) Area() int {
    return r.x * r.Y
}

type testRec struct {
    Rectangle	// 继承属性，不写不会继承属性，但是可以实现方法
}

// Area 可以调用，也可以像下面这样直接重写
// func (r *testRec) Area() int {
//     return r.x * r.Y
// }

func main() {
    rec := testRec{}
    rec.x = 10
    rec.Y = 4
    fmt.Println(rec.Area())
}
```

### 11.4. 多态

- 多态在go里面更多把思想转成接口
- 对外提供接口，但是存在不同实现

```go
// 定义接口Product，定义接口存在方法Use
type Product interface {
	Use()
}

// productA继承接口
type productA struct {
	Product
}

// 也可以继承另一个结构体
type productB struct {
	productA
}
```

### 11.5. 析构函数

- go可以给类设置析构函数，但是析构时机是GC触发的时机
- 如果进程直接退出，由操作系统回收内存，不会触发析构函数

```go
package main

import (
	"fmt"
	"runtime"
)

type testT struct {
	a    int
	next *testT
}

func main() {
	var root testT
	runtime.SetFinalizer(&root, func (tmp *testT)  {
		fmt.Println("hhh", tmp.a)
	})
}
```

### 11.6. 纯虚函数

- 对于go来说，不存在虚函数的概念，但是如果想要使用父类指针指向子类指针，必须实现父类定义的所有接口
- 接口类指向子类需要取地址，接口类可以直接调用自己的方法，会根据内存找到子类的方法调用
- **<font color="red">接口类指向子类内部只保存了子类的地址，所以参数传递可以值传递，改动会改动到内部子类的属性</font>**

```go
type TestI interface {
	TestFunc()
	Print()
}

type TestImpl struct{}

func (t *TestImpl) Print() {
	fmt.Println("TestImpl Print")
}

type TestImpl1 struct{}

func Constructor() TestI {
	return &TestImpl1{}		// 这里取地址
}

func (t *TestImpl1) TestFunc() {
	fmt.Println("TestImpl1 TestFunc")
}

func (t *TestImpl1) Print() {
	fmt.Println("TestImpl1 Print")
}

func main() {
	a := &TestImpl{} // 不会报错，没有实现不会认为是继承关系
	a.Print()
	var b TestI = &TestImpl{}	// 有这句话就会报错，因为TestImpl没有完全实现TestI
	var c TestI = Constructor()
	var d *TestI = &c
	c.Print()	// 可以正常调用，调用的是子类的方法
	d.Print()	// 报错，因为找不到 func (t *TestI)Print() 的实现
}
```

## 12. 指针

### 12.1. int转指针

- go中限制了指针类型的转换，不允许将int转成指针类型
- 但是，转换一下想法，用二级指针进行赋值即可

```go
var tmp **testT
tmp1 := 0x111111111
tmp = (**testT)(unsafe.Pointer(&tmp1))
fmt.Printf("%p", *tmp)
```

## 13. GC 垃圾回收机制

- GC（Garbage Collection）
- 下面内容参考自 [图解golang垃圾回收机制](https://zhuanlan.zhihu.com/p/390926887)

### 13.1. 内存管理

程序在内存上被分为堆区、栈区、全局数据区、代码段、数据区五个部分。对于C++等早期编程语言栈上的内存由编译器管理回收，堆上的内存空间需要编程人员负责申请与释放。在Go中栈上内存仍由编译器负责管理回收，而堆上的内存由编译器和垃圾收集器负责管理回收，给编程人员带来了极大的便利性。

<img src="2022-04-02-02.jpg" />

### 13.2. GC触发时机

触发GC有俩个条件，一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量GOGC，之后堆内存达到上一次垃圾收集的2倍时才会触发GC。二是如果一定时间内没有触发，就会触发新的循环，该触发条件由runtime.forcegcperiod变量控制，默认为2分钟。

### 13.3. GC带来的便利和坑

#### 1) 便利

```go
import (
	"fmt"
	"runtime"
	"time"
	"strconv"
	"unsafe"
)

type testT struct {
	a    int
	next *testT
}

func testFunc(root *testT) (arr []string) {
	for i := 0; i < 5; i++ {
		var tmp testT
		tmp.a = i
		// 引用了局部变量的地址，此变量在编译时会放到堆上而不是栈上
		root.next = &tmp
		arr = append(arr, fmt.Sprintf("%p", &tmp))
		// 这里加上析构函数查看触发时机
		runtime.SetFinalizer(&tmp, func (tmp *testT)  {
			fmt.Println("hhh", tmp.a)
		})
		root = root.next
	}
	return
}

func main() {
	var root testT

	arr := testFunc(&root)
	// 手动触发GC，这里什么都回收不掉，因为后面还在使用
	for i := 0; i < 10; i++ {
		time.Sleep(time.Second)
		runtime.GC()
	}
	for e := &root; e != nil; e = e.next {
		fmt.Println(e.a)
	}

	// 手动触发GC，GC一次回收一个变量
	for i := 0; i < 10; i++ {
		time.Sleep(time.Second)
		runtime.GC()
	}
	// 如果没有下面这一句使用了root，上面就会连带root的内存也回收掉，不会等到函数退出，因为分析后续没有再使用局部变量
	// 有下面这一句使用了root，上面就不会回收root和子节点
	fmt.Println(root.a)
}
```

## 14. struct

### 14.1. String() 默认打印方法

```go
type A struct {
	name string
}

// 实现String方法后，打印时会默认调用此方法
func (a A) String() string {
	return "A name: " + a.name
}

func main() {
	// 原型模式就是需要提供clone的接口，实现对对象的拷贝
	a := A{name: "a"}
	fmt.Println(a) // A name: a 默认调用String方法
}
```

### 14.2. 初始化父类属性

```go
type ProductA struct {
	Name string
}

type ProductB struct {
	ProductA
}

func main() {
	p := ProductB{
		ProductA: ProductA{
			Name: "ProductB",
		},
	}
	fmt.Println(p.Name)
}
```

## 15. 常量

- go中常量只能是数字、布尔、字符串，其他类型无法定义成常量

## 16. package 包

### 16.1. init函数

- init函数不可被调用，是golang提供的引入包就会调用的一个初始化函数
- 对于`package main`来说也是一样的，会在main函数调用前进行调用
- init可以定义多个，按照定义顺序执行

# 三、标准库

## 1. encoding/json

### 1.1. 一些基本操作

```go
package main

import (
	"encoding/json"
)

func main() {
	/****** 将json字符串序列化成go对象 ******/
	// 先marshal在unmarshal可以让一个未知的interface确定内部类型
	// Unmarshal可以将一个json字符串解析到一个特定的格式下
	// json.Unmarshal会将数字解析成float64
	json.Unmarshal(jsonBytes, &target)

	/****** 将go对象转成json字符串 ******/
	var f interface{}
	jsonBytes, err := json.Marshal(&f)
	// 格式化的字符串，第二个是前缀，第三个是缩进符号
	jsonIndentBytes, err := json.MarshalIndent(&f, "", "    ")
}
```

### 1.2. key排序转json

- go默认对`map[string]interface{}`转json按照key升序转化
- 想要对key排序只能通过结构体的方式，转json会按照结构体的顺序转化
- 为空的key不想输出，可以加上`omitempty`

```go
type outT struct {
	Type string `json:"type,omitempty"`
	Name string `json:"name,omitempty"`
}

func main() {
	var f outT
	str, _ := json.Marshal(&f)	// {}
}
```

### 注意事项

- 数字类型在Unmarshal之后会转成float64，只能断言为float64

## 2. testing 单测

- 单测文件要以`xxx_test.go`的格式，函数名以`Testxxx`的格式，package和要测试的文件属于同一个

```go
package service

import (
	"encoding/json"
	"errors"
	"reflect"
	"sort"
	"testing"

	"github.com/gin-gonic/gin"

	. "github.com/agiledragon/gomonkey"
	. "github.com/smartystreets/goconvey/convey"
)

func TestFunc(t *testing.T) {
	sess := session.Session{}
	var s *session.Session

    // hook类的成员函数Commit
	patch := ApplyMethod(reflect.TypeOf(s), "Commit", func(_ *session.Session) error { return nil })
	defer patch.Reset()

    // 使用Convey包裹，可以按照分组测试
	Convey("TestFunc", t, func() {
		Convey("正常流程", func() {
			Convey("插入单个数据", func() {
				sess.New()
                ...
                // So确定
				So(tmp, ShouldResemble, []string{"aaa"})
			})
		})
		Convey("异常流程", func() {
			Convey("GetSessionData出错", func() {
				sess.New()
				...
				patch1 := ApplyMethod(reflect.TypeOf(s), "GetSessionData",
					func(_ *session.Session, _ string) (interface{}, error) {
						return nil, errors.New("testErr")
					})
				...
				So(tmp, ShouldResemble, []string{})
				patch1.Reset()
				...
				So(tmp, ShouldResemble, []string{"bbb"})
			})
		})
	})
}
```

### 2.2. 性能分析

参考[go 性能优化之 benchmark + pprof](https://zhuanlan.zhihu.com/p/332613357)

## 3. flag 控制台参数解析

### 3.1. 获取命令行参数

```go
package main

import (
	"fmt"
	"flag"
)

func main() {
	// 在使用前先调用此函数解析参数，不然会返回空
	flag.Parse()
	// 打印第一个参数
	fmt.Println(flag.Arg(0))
	// 打印所有非flag的参数
	fmt.Println(flag.Args())
	// 打印参数个数
	fmt.Println(flag.NArg())
}
```

输出

```shell
=> go run main.go a -a -b -asdfsaf cccc
a
[a -a -b -asdfsaf ccc]
5
```

## 4. path/filepath 目录操作库

### 4.1. 遍历目录下所有文件和目录，类似 `find xxx`

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "path/filepath"
)

func getFileList(path string) {
    err := filepath.Walk(path, func(path string, f os.FileInfo, err error) error {
        if f == nil {
            return err
        }
        if f.IsDir() {
            return nil
        }
        println(path)
        return nil
    })
    if err != nil {
        fmt.Printf("filepath.Walk() return %v\n", err)
    }
}

func main() {
    flag.Parse()
	var root string
    root = flag.Arg(0)
    getFileList(root)
}
```

输出

```shell
=> go run main.go .
go.mod
main.go
=> go run main.go ./
go.mod
main.go
=> go run main.go ../
../test/go.mod
../test/main.go
=> go run main.go /path/to/test
/path/to/test/go.mod
/path/to/test/main.go
```

### 4.2. 路径处理

```go
func test() {
	filePath := "/home/wangyubo/aaaa/test.txt"
	fmt.Println(filepath.Base(filePath))	// 文件名 test.txt
	fmt.Println(filepath.Dir(filePath))		// 路径名 /home/wangyubo/aaaa
}
```

## 5. os/exec 命令行调用

### 5.1. 阻塞式等待返回，并输出stdout

```go
package main

import (
    "bytes"
    "fmt"
    "os/exec"
)

func execShell(s string) (string, error) {
    cmd := exec.Command("/bin/bash", "-c", s)

    var out bytes.Buffer
    cmd.Stdout = &out

    err := cmd.Run()
    if err != nil {
        fmt.Printf("%v\n", err)
    }

    return out.String(), err
}

func main() {
    fmt.Println(execShell("ls /"))
}
```

## 6. net/http http网络请求库

### 6.1. 发送post请求

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func main() {
	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
    if err != nil {
        fmt.Println(err)
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(string(body))
}
```

### 6.2. 忽略https的证书错误

#### (1) 修改默认客户端

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
    "crypto/tls"
)

func main() {
	http.DefaultClient.Transport = &http.Transport{
        TLSClientConfig: &tls.Config{
            InsecureSkipVerify: true,
        },
    }

	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
	...
}
```

## 7. strings 字符串操作库

### 7.1. 字符串替换

```go
package main

import (
	"strings"
)

func main() {
	outStr := '{"a":"123"}'
	// 将json中的双引号全部替换为单引号
	outStr = strings.ReplaceAll(outStr, `"`, `'`)
}
```

### 7.2. 裁剪两端字符串

- 只能裁剪两端的字符串，中间的不会裁剪

```go
outStr := "abffffffffabfffffffab"
outStr = strings.Trim(outStr, "ab")		// ffffffffabfffffff
```

### 7.3. 字符串分割

**Split**

- 根据某字符串分割

```go
arr := strings.Split("a,b,c", ",")	// [a b c]
```

**Fields**

- 根据空格分割，多个空格视为一个

```go
arr := strings.Fields("a b  c   d") // [a b c d]
```

### 7.4. 字符串比较

**Compare**

```go
if strings.Compare(event1[1], event2[0]) < 0 {
	// do something
}
```

## 8. encoding/hex 十六进制操作库

### 8.1. 将十六进制字符串转成数组

```go
arr, err := hex.DecodeString("aabbcc")	// [170 187 204]
```

### 8.2. 将[]byte按照十六进制打印成字符串

```go
hexStr := hex.EncodeToString([]byte("123456"))	// 313233343536
```

## 9. io/ioutil io操作（到go1.16之后可以使用io或os库替代）

### 9.1. 文件读取

```go
contentBytes, err := ioutil.ReadFile("/a/b/c.txt")
```

## 10. os 系统操作

### 10.1. 目录操作

#### 1) 基本操作

```go
//判断目录是否存在
_, err := os.Stat("./")
if err != nil && os.IsNotExist(err) {
	// 目录不存在
}

// 获取当前二进制执行路径
execFilePath, _ := os.Executable()
fmt.Println(execFilePath)	// /home/xxx/local/go/tools/tool

// 获取temp目录路径
os.TempDir()

// 切换工作目录
err := os.Chdir("/tmp")

// 创建目录
err := os.Mkdir(currentPath+"/tmp", 0777)			// 类似mkdir xxx/tmp
err := os.MkdirAll(currentPath+"/tmp/a/b", 0777)	// 类似mkdir -p xxx/tmp/a/b

// 删除目录
err := os.Remove(currentPath + "/tmp")		// 删除文件或空文件夹
err := os.RemoveAll(currentPath + "/tmp")	// 删除目录及其子目录
```

### 10.2. 文件读取

#### 1) 整个文件读取

```go
contentBytes, err := os.ReadFile("/a/b/c.txt")
```

#### 2) 按行读取

```go
func (s *defaultParser) ParseFile(filePath string, handler func(log string)) {
	f, err := os.Open(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	rd := bufio.NewReader(f)
	for {
		line, err := rd.ReadString('\n') //以'\n'为结束符读入一行
		fmt.Println(line)
		if err != nil || io.EOF == err {
			break
		}
	}
}
```

## 11. stronv

```go
package main
import (
    "strconv"
    "fmt"
)
func main() {
    // 使用ParseFloat解析浮点数，64是说明使用多少位
    // 精度来解析
    f, _ := strconv.ParseFloat("1.234", 64)
    fmt.Println(f)

    // 对于ParseInt函数，0 表示从字符串推断整型进制，
    // 则表示返回结果的位数
    i, _ := strconv.ParseInt("123", 0, 64)
    fmt.Println(i)

    // ParseInt能够解析出16进制的数字
    d, _ := strconv.ParseInt("0x1c8", 0, 64)
    fmt.Println(d)

    // 还可以使用ParseUint函数
    u, _ := strconv.ParseUint("789", 0, 64)
    fmt.Println(u)

    // Atoi是解析10进制整型的快捷方法
    k, _ := strconv.Atoi("135")
    fmt.Println(k)

    // 解析函数在遇到无法解析的输入时，会返回错误
    _, e := strconv.Atoi("wat")
    fmt.Println(e)
}
```

## 12. net 网络库

### 12.1. udp发送和接受

**客户端**

```go
package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
)

func main() {
	flag.Parse()
	if flag.NArg() < 2 {
		log.Fatalln("Must input 2 params")
	}
	serverAddr := flag.Arg(0)
	filePath := flag.Arg(1)

	fmt.Printf("client, serverAddr: %s, filePath: %s\r\n", serverAddr, filePath)

	conn, err := net.Dial("udp", serverAddr)
	if err != nil {
		log.Fatalln(err)
	}
	defer conn.Close()

	f, err := os.Open(filePath)
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()

	buf := make([]byte, 50*1024)
	count := 0
	i := 0
	for {
		n, err := f.Read(buf)
		if err != nil {
			if err == io.EOF {
				break
			} else {
				log.Fatalln(err)
			}
		}
		sendSize, err := conn.Write(buf[:n])
		if err != nil {
			log.Fatalln(err)
		}
		count += sendSize

		msg := make([]byte, 128)
		_, err = conn.Read(msg)
		if err != nil {
			log.Fatalln(err)
		}

		fmt.Printf("%d, Send %d, check %s\r\n", i, n, string(msg))
		i++
	}

	fmt.Printf("Send %s to %s success, size %d", serverAddr, filePath, count)
}
```

**服务端**

```go
package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"os"
)

func main() {
	flag.Parse()
	if flag.NArg() < 2 {
		log.Fatalln("Must input 2 params")
	}
	serverAddr := flag.Arg(0)
	filePath := flag.Arg(1)

	fmt.Printf("Hello, main, serverAddr: %s, filePath: %s\r\n", serverAddr, filePath)

	f, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	addr, err := net.ResolveUDPAddr("udp", serverAddr)
	if err != nil {
		log.Fatalln(err)
	}

	conn, err := net.ListenUDP("udp", addr)
	if err != nil {
		log.Fatalln(err)
	}
	defer conn.Close()

	i := 0
	for {
		data := make([]byte, 100*1024)
		n, rAddr, err := conn.ReadFromUDP(data)
		if err != nil {
			fmt.Println(err)
			continue
		}

		fmt.Printf("%d, Recieved from %s size %d\r\n", i, rAddr.String(), n)

		f.Write(data[:n])
		i++

		_, err = conn.WriteToUDP([]byte(fmt.Sprintf("%d", n)), rAddr)
		if err != nil {
			fmt.Println(err)
			continue
		}
	}
}
```

## 13. time 时间库

### 13.1. 时间戳操作

```go
package main

import (
	"time"
)

func main() {
	timestampS := time.Now().Unix()		// 秒级时间戳
}
```

## 14. sort 排序

### 14.1. 基本类型排序

#### 1) 升序

```go
package main

import (
	"sort"
)

func main() string {
	var queryKeyList []string
	var intList []int

	sort.Strings(queryKeyList)
	sort.Ints(intList)
}
```

#### 2) 降序

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	testArr := []int{2, 7, 4, 9, 1, 4, 8}

	sort.Sort(sort.Reverse(sort.IntSlice(testArr)))
	fmt.Println(testArr)
}
```

- 解释一下上面的代码，`sort.IntSlice(testArr)`是将`[]int`强转成`sort.IntSlice`类型，类型定义了sort需要的三个函数，本质上还是`[]int`
- `sort.IntSlice`是`sort.Interface`的一个子类实现
- `sort.Reverse(xxx)`将传入的`sort.Interface`转成`sort.reverse`类型返回
- 同样`sort.reverse`也是`sort.Interface`的一个子类实现，将`Less()`方法重写，反着调用原方法
- `sort.Sort()`将`sort.Interface`进行排序

### 14.2. 二分查找

- sort包提供两个函数进行二分查找，并提供了一些基本类型的查找

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	a := []int{1, 2, 2, 4, 4, 5}

	// 二分查找从最左边开始的第一个满足条件的索引
	fmt.Println(sort.Search(len(a), func(i int) bool { return a[i] >= 2 })) // 1
	// 二分查找从最左边开始第一个 func(i) <= 0 的索引，并返回对应索引是否 func(i) == 0
	fmt.Println(sort.Find(len(a), func(i int) int { return 3 - a[i] })) // 3, false
	// 基本类型可以直接调用，但是只支持升序的slice
	// 源码就是调用 sort.Search(len(a), func(i int) bool { return a[i] >= 2 }
	fmt.Println(sort.SearchInts(a, 2)) // 1
}
```

### 14.3. 自定义类型排序

- 需要定义一个类型的三个接口，然后调用`sort.Sort`即可

```go
type NameSlice struct {
	names   []string
	heights []int
}

func (x NameSlice) Len() int           { return len(x.names) }
// 为true，i向前；false，j向前。要满足相等时返回false
func (x NameSlice) Less(i, j int) bool { return x.heights[i] > x.heights[j] }
func (x NameSlice) Swap(i, j int) {
	x.heights[i], x.heights[j] = x.heights[j], x.heights[i]
	x.names[i], x.names[j] = x.names[j], x.names[i]
}

func sortPeople(names []string, heights []int) []string {
	tmp := NameSlice{
		names:   names,
		heights: heights,
	}
	sort.Sort(tmp)
	return tmp.names
}
```

## 15. image 图像库

### 15.1. png处理

```go
package main

import (
	"bytes"
	"fmt"
	"image"
	"image/color"
	"image/png"		// 包含这个才能解析png图片
	"io/ioutil"
	"os"
)

func main() {
	originByte, _ := ioutil.ReadFile("./test.png")
	originBuffer := bytes.NewBuffer(originByte)
	originImg, filename, err := image.Decode(originBuffer)
	if err != nil {
		return err.Error()
	}
	fmt.Println(filename)	// png
	imgBounds := img.Bounds()
	imgX := imgBounds.Dx()		// 宽度
	imgY := imgBounds.Dy()		// 高度

	firstRgba := img.At(0, 0)	// 获取一个位置的像素点
	r, g, b, a := firstRgba.RGBA()

	// 创建一个新的图片，范围是100x100
	newImg := image.NewRGBA(image.Rectangle{
		Min: image.Point{X: 0, Y: 0},
		Max: image.Point{X: 100, Y: 100},
	})
	// 坐标 (5, 5) 涂黑
	newImg.SetRGBA(5, 5, color.RGBA{
		R: 0,
		B: 0,
		G: 0,
		A: 255,		// 不透明
	})

	// 保存到output.png
	f, _ := os.Create("./output.png")
	png.Encode(f, newImg)
	defer f.Close()
}
```

## 16. container/list 双向链表

- value可以是任意类型的值
- **<font color="red">list本身不能拷贝，因为里面的element有一个指针指向root的地址，如果拷贝，root会被复制一份，将会导致element失效</font>**
- 需要将list放到结构体时，建议使用指针放置

### 16.1. 基本操作

```go
// 初始化
tmp := list.New()
tmp.PushBack(1)  // 向后插入
tmp.PushFront(3) // 向前插入
// 遍历
for e := tmp.Front(); e != nil; e = e.Next() {
	fmt.Println(e.Value)
}
// 删除
for e := tmp.Front(); e != nil; e = e.Next() {
	if e.Value == 3 {
		tmp.Remove(e)
		break
	}
}
// 中间插入
for e := tmp.Front(); e != nil; e = e.Next() {
	if e.Value == 3 {
		// 向后插入
		tmp.InsertAfter(1, e)
		// 向前插入
		tmp.InsertBefore(2, e)
		break
	}
}
```

### 踩坑记

#### 1) list放到结构体里面一定要注意结构体拷贝的问题，建议在结构体里面使用指针

```go
type test struct {
	head list.List
}

func main() {
	tmp := test{}
	tmp.head.PushFront(1)

	tmp2 := tmp	// 拷贝会导致里面的元素的root指向错误，导致下面的插入语句错误
	tmp2.head.InsertAfter(2, tmp2.head.Front())
	// 这里打印只有一个1，前面的插入失效
	for e := tmp2.head.Front(); e != nil; e = e.Next() {
		fmt.Println(e.Value)
	}
}
```

- 原因从源码查看

```go
// src/container/list/list.go
// Element is an element of a linked list.
type Element struct {
	// Next and previous pointers in the doubly-linked list of elements.
	// To simplify the implementation, internally a list l is implemented
	// as a ring, such that &l.root is both the next element of the last
	// list element (l.Back()) and the previous element of the first list
	// element (l.Front()).
	next, prev *Element

	// The list to which this element belongs.
	list *List

	// The value stored with this element.
	Value any
}
...
// List represents a doubly linked list.
// The zero value for List is an empty list ready to use.
type List struct {
	root Element // sentinel list element, only &root, root.prev, and root.next are used
	len  int     // current list length excluding (this) sentinel element
}
...
// InsertAfter inserts a new element e with value v immediately after mark and returns e.
// If mark is not an element of l, the list is not modified.
// The mark must not be nil.
func (l *List) InsertAfter(v any, mark *Element) *Element {
	if mark.list != l {
		return nil
	}
	// see comment in List.Remove about initialization of l
	return l.insertValue(v, mark)
}
```

- 上面的Element里面有一个变量list指向root的地址，也就是下面InsertAfter判断的值
- 当进行了拷贝之后，root本身是拷贝的，地址处于新的地址上，里面的元素的list还指向拷贝前的地址，自然和当前不相等，就会插入失败
- 解决办法就是使用指针，这样拷贝的是指针，里面的内容不会变化
- 上面的写法只是实例，实际场景经常会出现在构造函数构造完元素后返回了一个拷贝，如下面的错误写法

```go
type Allocator struct {
	memMap  list.List
}

func Constructor(n int) Allocator {
	res := Allocator{}
	res.memMap.PushFront(1)
	// 返回拷贝，外层拷贝时将memMap的内容拷贝过去，导致元素的list失效
	return res
}
```

## 17. runtime 一些运行需要的变量和方法

### 17.1. 常用变量

#### 1) runtime.GOOS 操作系统类型

```go
func test() {
	switch runtime.GOOS {
	case "windows":
		fmt.Println("windows")
	case "linux":
		fmt.Println("linux")
	case "darwin":
		fmt.Println("mac")
	default:
		log.Fatalln("unsupported os", runtime.GOOS)
	}
}
```

## 18. io io相关操作

## 19. regexp 正则库

### 19.1. 提取字符串

- 括号内的是要提取的字符串，输出为整体匹配到的字符串加括号匹配的字符串

```go
func TestRegexDefault(t *testing.T) {
	line := "[2022-12-26 18:49:24.631][ 25160:  6372][ info][aaa][bbb]testhhh\r\n"

	defaultRegexStr := `^\[(20[0-9]{2}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3})\]\[[ ]*(\w+):[ ]*(\w+)\]\[[ ]*(\w+)\]\[(\w+)\]\[[^\]]*\](.*)`
	matchRegex := regexp.MustCompile(defaultRegexStr)
	params := matchRegex.FindStringSubmatch(line)
	if len(params) == 0 {
		t.Fatal(defaultRegexStr, " parse failed, params ", params)
	}
	fmt.Println(params)	// ["[2022-12-26 18:49:24.631][ 25160:  6372][ info][aaa][bbb]testhhh\r" "2022-12-26" "18:49:24.631" "25160" "6372" "info" "aaa" "testhhh"]
}
```

## 20. archive/zip zip相关操作

### 20.1. 解压缩

```go
func unzip(zipFile string, destDir string) error {
	zipReader, err := zip.OpenReader(zipFile)
	if err != nil {
		return err
	}
	defer zipReader.Close()

	for _, f := range zipReader.File {
		fpath := filepath.Join(destDir, f.Name)
		if f.FileInfo().IsDir() {
			os.MkdirAll(fpath, os.ModePerm)
		} else {
			if err = os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {
				return err
			}

			inFile, err := f.Open()
			if err != nil {
				return err
			}
			defer inFile.Close()

			outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
			if err != nil {
				return err
			}
			defer outFile.Close()

			_, err = io.Copy(outFile, inFile)
			if err != nil {
				return err
			}
		}
	}
	return nil
}
```

### 20.2. 压缩

```go
// srcFile could be a single file or a directory
func Zip(srcFile string, destZip string) error {
    zipfile, err := os.Create(destZip)
    if err != nil {
        return err
    }
    defer zipfile.Close()

    archive := zip.NewWriter(zipfile)
    defer archive.Close()

    filepath.Walk(srcFile, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        header, err := zip.FileInfoHeader(info)
        if err != nil {
            return err
        }


        header.Name = strings.TrimPrefix(path, filepath.Dir(srcFile) + "/")
        // header.Name = path
        if info.IsDir() {
            header.Name += "/"
        } else {
            header.Method = zip.Deflate
        }

        writer, err := archive.CreateHeader(header)
        if err != nil {
            return err
        }

        if ! info.IsDir() {
            file, err := os.Open(path)
            if err != nil {
                return err
            }
            defer file.Close()
            _, err = io.Copy(writer, file)
        }
        return err
    })

    return err
}
```

## 21. exec 执行命令

### 21.1. 打开浏览器

```go
func openBrowser(url string) {
	command := ""
	args := []string{}
	switch runtime.GOOS {
	case "windows":
		command = "start"
		args = append(args, "/c")
		args = append(args, "start")
	case "linux":
		command = "xdg-open"
	case "darwin":
		command = "open"
	}
	args = append(args, url)

	fmt.Println("exec", command, args)
	cmd := exec.Command(command, args...)
	cmd.Start()
}
```

# 四、go命令相关

## 1. go test 执行单测用例

```shell
########## 指定目录 ##########
# 执行当前目录下所有单测文件
go test
# 执行当前package的某个子目录单测文件
go test [package]/[dir]

########## 指定函数 ##########
# 执行特定函数
go test -run ^testFunc$
# 执行多个特定函数
go test -run ^(testFunc|testFunc1)$

########## 设定超时时间 ##########
go test -timeout 30s

########## 打印详细信息 ##########
# 默认成功不会打印fmt.Println等，加上-v就会打印
go test -v
```

## 2. go build 编译二进制

- go build不区分平台，可以在任意系统上编译其他大多数系统的版本

### 2.1. windows 32bit和64bit

```shell
# 32位编译
go env -w GOOS=windows
go env -w GOARCH=386
go build
go env -u GOARCH
go env -u GOOS

# 64位编译
go env -w GOOS=windows
go env -w GOARCH=amd64
go build
go env -u GOARCH
go env -u GOOS
```

### 2.2. 全平台编译makefile示例

```makefile
TARGET_NAME		= testaaa
BUILD_CMD		= go build
OUTPUT 			= $(TARGET_NAME)_x86.exe $(TARGET_NAME)_x64.exe $(TARGET_NAME)_linux_amd64 $(TARGET_NAME)_linux_arm64 $(TARGET_NAME)_mac_amd64 $(TARGET_NAME)_mac_arm64

all: $(OUTPUT)
clean:
	rm -f $(OUTPUT)

$(TARGET_NAME)_x86.exe: *.go
	go env -w GOOS=windows
	go env -w GOARCH=386
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_x64.exe: *.go
	go env -w GOOS=windows
	go env -w GOARCH=amd64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_linux_amd64: *.go
	go env -w GOOS=linux
	go env -w GOARCH=amd64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_linux_arm64: *.go
	go env -w GOOS=linux
	go env -w GOARCH=arm64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_mac_amd64: *.go
	go env -w GOOS=darwin
	go env -w GOARCH=arm64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH

$(TARGET_NAME)_mac_arm64: *.go
	go env -w GOOS=darwin
	go env -w GOARCH=arm64
	$(BUILD_CMD) -o $@
	go env -u GOOS
	go env -u GOARCH
```

### 2.3. 编译给c调用的动态库

**代码上**

- 必须有`package main`和main函数，但是可以什么都不做
- 必须包含`import "C"`
- 要导出的函数必须加上`//export funcName`，export前没有空格
- 导出函数本身无所谓首字母大小写

```go
package main

import "fmt"
import "C"

// Rectangle define class
type Rectangle struct {
    x int
    y int
}

// Area define method
func (r *Rectangle) Area() int {
    return r.x * r.y
}

//export test
func test() {
    rec := Rectangle{
        x: 14,
        y: 34,
    }
    fmt.Println(rec.Area())
}

func main() {
}
```

**编译**

```shell
# 要先安装标准库，会生成目录到 /usr/lib/go/pkg/linux_[arch]_dynlink/
go install -buildmode=shared -linkshared std
# 编译C动态库
go build -buildmode=c-shared -linkshared -o libtest.so
```

**结果**

- 会在当前目录生成一个静态库文件（`libtest.so`）一个头文件（`libtest.h`）
- strip后查看`libtest.so`，函数已经导出，依赖上述生成的目录下的`libstd.so`

```shell
=> strip libtest.so
=> readelf -Ws libtest.so

Symbol table '.dynsym' contains 33 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.17 (2)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.17 (2)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.morestack_noctxt
     7: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.int
     8: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.*os.File
     9: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND os.Stdout
    10: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.io.Writer
    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.addmoduledata
    12: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND os.(*File).Write
    13: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND go.link.abihash.libstd.so
    14: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.unreachableMethod
    15: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.convT64
    16: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _rt0_arm64_linux_lib
    17: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND runtime.lastmoduledatap
    18: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND runtime.tlsg
    19: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fmt.Fprintln
    20: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND __stack_chk_guard@GLIBC_2.17 (3)
    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _cgo_wait_runtime_init_done
    22: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND crosscall2
    23: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _cgo_release_context
    24: 000000000001f950     8 OBJECT  GLOBAL DEFAULT   19 _rt0_arm64_linux_lib.ptr
    25: 0000000000020238     0 NOTYPE  GLOBAL DEFAULT   18 _edata
    26: 0000000000020239     0 NOTYPE  GLOBAL DEFAULT   18 _end
    27: 0000000000001270    64 FUNC    GLOBAL DEFAULT   13 _cgoexp_f70364e750d1_test
    28: 00000000000012b0   144 FUNC    GLOBAL DEFAULT   13 main.test
    29: 0000000000001350   128 FUNC    GLOBAL DEFAULT   13 test
    30: 0000000000020238     0 NOTYPE  GLOBAL DEFAULT   18 __bss_start
    31: 000000000001f988    32 OBJECT  GLOBAL DEFAULT   20 go.itab.*os.File,io.Writer
    32: 000000000001f970    24 OBJECT  GLOBAL DEFAULT   20 runtime.textsectionmap

# 可以看到依赖了go自己的标准库和libc的库
=> readelf -d libtest.so

Dynamic section at offset 0xfce8 contains 32 entries:
  Tag        Type                         Name/Value
 0x0000000000000003 (PLTGOT)             0x1ff88
 0x0000000000000002 (PLTRELSZ)           264 (bytes)
 0x0000000000000017 (JMPREL)             0xf90
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000007 (RELA)               0x948
 0x0000000000000008 (RELASZ)             1608 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffff9 (RELACOUNT)          55
 0x0000000000000006 (SYMTAB)             0x288
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000005 (STRTAB)             0x5a0
 0x000000000000000a (STRSZ)              700 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x860
 0x0000000000000001 (NEEDED)             Shared library: [libstd.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-aarch64.so.1]
 0x000000000000000c (INIT)               0x1098
 0x000000000000000d (FINI)               0x13d0
 0x000000000000001a (FINI_ARRAY)         0x1f940
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x0000000000000019 (INIT_ARRAY)         0x1f948
 0x000000000000001b (INIT_ARRAYSZ)       24 (bytes)
 0x000000000000001d (RUNPATH)            Library runpath: [/usr/lib/go/pkg/linux_arm64_dynlink/]
 0x0000000000000010 (SYMBOLIC)           0x0
 0x000000000000001e (FLAGS)              SYMBOLIC BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW NODELETE
 0x000000006ffffff0 (VERSYM)             0x8a8
 0x000000006ffffffc (VERDEF)             0x8ec
 0x000000006ffffffd (VERDEFNUM)          1
 0x000000006ffffffe (VERNEED)            0x908
 0x000000006fffffff (VERNEEDNUM)         2
 0x0000000000000000 (NULL)               0x0
```

## 3. go env 设置环境变量

```shell
# 设置环境变量
go env -w xxx=xx
# 恢复环境变量到默认值
go env -u xxx
```

**实例**

- 可以写到makefile中，跨平台的makefile

```makefile
main.exe: main.go
	go env -w GOOS=windows
	go build
	go env -u GOOS
```

## 4. go install 安装全局包

```shell
go install -v github.com/cweill/gotests/gotests@v1.6.0
```

# 五、框架

## 1. 工程知识

### 1.1. go.mod

- `go.mod`是go工程用来管理包使用的，类似于nodejs的`package.json`文件

#### 1) 创建新工程

**1. 先生成go.mod文件**

```shell
# 初始化一个test工程
go mod init test
```

#### 2) go mod 一些基本操作

```shell
# 添加工程依赖包，会加入到go.mod文件中的require中
go mod download github.com/mattn/go-sqlite3
# 根据go.mod文件处理依赖关系
go mod tidy
```

##### (1) vendor

```shell
# 同步依赖包到当前的vendor目录
go mod vendor
```

## 2. goframe

### 2.1. 安装配置

**安装gf命令行工具**

- goframe安装需要一个gf命令行工具

```shell
# 下载安装gf
wget -O gf https://github.com/gogf/gf-cli/releases/download/v1.16.3/gf_linux_amd64 && chmod +x gf && ./gf install
```

- 默认gf命令行工具不支持sqlite3，如果需要，上面安装完之后，自己编译一版sqlite3的gf工具
- 确保有gcc编译环境

```shell
# clone仓库
git clone https://github.com/gogf/gf-cli && cd gf-cli
# 设置环境变量
export CGO_ENABLED=1
# 将代码中的sqlite3依赖取消注释
vim command/gen/gen_dao.go
...
# 执行gf的编译命令，需要上述步骤先下载gf工具
# -a指定平台，可以编译下面几种平台
#       darwin    amd64,arm64
#       freebsd   386,amd64,arm
#       linux     386,amd64,arm,arm64,ppc64,ppc64le,mips,mipsle,mips64,mips64le
#       netbsd    386,amd64,arm
#       openbsd   386,amd64,arm
#       windows   386,amd64
gf build main.go -a amd64 -s linux --cgo
# 安装
cp bin/linux_amd64/gf /usr/local/bin/gf
```

**初始化**

- 如果需要使用sqlite3，需要在项目根目录执行

```shell
go mod download github.com/mattn/go-sqlite3
```

**代码生成**

- 根据`config.toml`生成数据库代码，这个比较方便

```shell
gf gen dao -c config/config.toml
```

### 2.2. 开发知识点

#### 2.2.1. orm时间维护功能

- orm的数据库更新操作会自动更新updatedAt、createdAt、deletedAt等字段
- 不想要更新字段需要加上`Unscoped()`

```go
db.Table("user").Unscoped().Data(g.Map{"name" : "john guo"}).Where("name", "john").Update()
```

### 2.2.2. 前后端字段对应

- gf中使用下面的方法可以将前端传入参数解析到struct的对应成员中

```go
// app/model/xxx.go
type TaskApiCreateReq struct {
	Content  string `json:"content" v:"required|length:1,100#任务内容不能为空|任务内容应当在:min到:max之间"`
	TaskType int    `json:"taskType"`
}
// app/api/xxx.go
func (a *task) Create(r *ghttp.Request) {
	var (
		data *model.TaskApiCreateReq
	)
	if err := r.Parse(&data); err != nil {
		response.JsonExit(r, 1, err.Error())
	}
	...
}
```

- 解析规则，会把前端传入的字段去除除了字母和数字的所有特殊字符，然后不区分大小写比较
- 下面的几个key都可以解析到上面的`data.Content`中

```json
{
	"Content": "xxx",
	"content": "xxx",
	"con_tent": "xxx",
	"conTent": "xxx"
}
```

# 六、好用的第三方库

## 1. uuid

```go
package main

import (
	"fmt"

	"github.com/google/uuid"
)

func main() {
	id := uuid.New()
	fmt.Printf("%s %s\n", id, id.Version().String())
}
```

**输出**

```
ab8d63ef-f0c4-a01d-a6ef-5f2c3efff5af VERSION_4
```

## 2. `github.com/makiuchi-d/gozxing` 二维码解析和生成

- `github.com/tuotoo/qrcode`没成功的，这个成功了

```go
package main

import (
	"bytes"
	"fmt"
	"image"
	"image/png"
	"io/ioutil"

	"github.com/makiuchi-d/gozxing"
	_ "github.com/makiuchi-d/gozxing/common"
	"github.com/makiuchi-d/gozxing/qrcode"
)

func parseQrcode(pngPath string) string {
	originByte, _ := ioutil.ReadFile(pngPath)
	originBuffer := bytes.NewBuffer(originByte)
	originImg, _, err := image.Decode(originBuffer)
	if err != nil {
		return err.Error()
	}
	fmt.Println(filename)

	// 解析二维码返回结果
	bmp, _ := gozxing.NewBinaryBitmapFromImage(originImg)
	qrReader := qrcode.NewQRCodeReader()
	result, err := qrReader.Decode(bmp, nil)
	if err != nil {
		return err.Error()
	}
	return result.GetText()
}
```

## 3. `golang.org/x/mobile` go开发android和ios

[gomobile使用笔记](/blogs/2022-05-24-gomobile)

## 4. `github.com/shirou/gopsutil/process` 获取进程相关信息

### 4.1. 获取进程信息

```go
// 获取进程对应的目录
func getProcessDir(name string) string {
	// 获取所有进程id
	pids, _ := process.Pids()
	for _, pid := range pids {
		p, _ := process.NewProcess(int32(pid))
		tmp, _ := p.Name()
		if tmp != name {
			continue
		}
		fmt.Println(p.Name())		// 名称，一般是二进制名称
		fmt.Println(p.Exe())		// 二进制路径
		fmt.Println(p.Cwd())		// 二进制运行环境变量
		fmt.Println(p.Cmdline())	// 二进制运行命令行参数
		fmt.Println(p.Uids())
		fmt.Println(p.Gids())
		fmt.Println(p.Username())
		fmt.Println(p.CreateTime())
		fmt.Println(p.MemoryInfo())
		fmt.Println(p.MemoryInfoEx())
		fmt.Println(p.NumCtxSwitches())
		fmt.Println(p.NumFDs())
		fmt.Println(p.NumThreads())
		fmt.Println(p.OpenFiles())
		fmt.Println(p.Connections())
		fmt.Println(p.IsRunning())
		break
	}
	return ""
}
```

## 5. `github.com/miekg/dns` 构造dns包发送

### 5.1. 获取域名特定类型的解析

```go
func resolveDomain(domain string, server string, dnsType uint16) (r *dns.Msg, err error) {
	cli := dns.Client{
		Timeout: 5 * time.Second,
	}
	m := dns.Msg{}
	m.SetQuestion(dns.Fqdn(domain), dnsType)
	m.Id = dns.Id()
	m.RecursionDesired = false

	r, _, err = cli.Exchange(&m, server+":53")
	if err != nil {
		return
	}
	fmt.Println(r.String())	// 打印类似dig的输出
}
```

## 6. `golang.org/x/text/encoding/simplifiedchinese` 中文编码转换

```go
import "golang.org/x/text/encoding/simplifiedchinese"

func ConvertStr2GBK(str string) string {
    //将utf-8编码的字符串转换为GBK编码
    ret, err := simplifiedchinese.GBK.NewEncoder().String(str)
    return ret   //如果转换失败返回空字符串

    //如果是[]byte格式的字符串，可以使用Bytes方法
    b, err := simplifiedchinese.GBK.NewEncoder().Bytes([]byte(str))
    return string(b)
}

func ConvertGBK2Str(gbkStr string) string {
    //将GBK编码的字符串转换为utf-8编码
    ret, err := simplifiedchinese.GBK.NewDecoder().String(gbkStr)
    return ret //如果转换失败返回空字符串

    //如果是[]byte格式的字符串，可以使用Bytes方法
    b, err := simplifiedchinese.GBK.NewDecoder().Bytes([]byte(gbkStr))
    return string(b)
}
```

# 七、实战

## 1. 搭建简单http服务器

### 1.1. 模板

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

type retJson struct {
	Code  int    `json:"code"`
	LLLL  string `json:"llll"`
	AAAA  string `json:"aaaa"`
	Token string `json:"token"`
}

func smsServerHandler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	fmt.Println(r.Form)
	fmt.Println("path", r.URL.Path)
	fmt.Println("scheme", r.URL.Scheme)

	var ret retJson
	ret.Code = 0
	ret.LLLL = "test"
	ret.AAAA = "stest"
	ret.Token = "a454as1bbvd5g5s15155"
	retBytes, _ := json.MarshalIndent(&ret, "", "    ")
	retStr := string(retBytes)
	fmt.Println(retStr)

	w.Header().Set("Content-Type", "application-json")
	fmt.Fprintf(w, retStr)
}

func main() {
	// 接口处理到函数
	http.HandleFunc("/", smsServerHandler)
	// 接口处理到目录，主要用于静态页面返回
	http.Handle("/", http.FileServer(http.Dir("template")))
	err := http.ListenAndServe(":7878", nil)
	if err != nil {
		log.Fatal("ListenAndServe failed, err: ", err)
	}
}
```

### 1.2. 静态页面路径返回

**最简单跟目录返回**

```go
package main

import (
	"log"
	"net/http"
)

func main() {
	// 接口处理到目录，主要用于静态页面返回
	http.Handle("/", http.FileServer(http.Dir("template")))
	err := http.ListenAndServe(":7878", nil)
	if err != nil {
		log.Fatal("ListenAndServe failed, err: ", err)
	}
}
```

**其他路径返回页面**

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 访问根转发到template
	if r.URL.Path == "/" {
		http.Redirect(w, r, "/template/", http.StatusFound)
		return
	}
	w.Write([]byte(r.URL.Path))
}

func main() {
	// 返回界面，将 /template/ 裁掉访问目录
	http.Handle("/template/", http.StripPrefix("/template/", http.FileServer(http.Dir("./template"))))
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

### 1.3. 上传文件

```go
package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
)

func uploadHandler(w http.ResponseWriter, r *http.Request) {
	// 获取表单的file字段
	file, handler, err := r.FormFile("file")
	if err != nil {
		fmt.Println("upload failed, err:", err)
		w.Write([]byte("upload success"))
		return
	}
	defer file.Close()

	// 本地创建文件
	f, err := os.Create("./upload_dir/" + handler.Filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	// 文件保存
	_, err = io.Copy(f, file)
	if err != nil {
		panic(err)
	}
	w.Write([]byte("upload success"))
}

func main() {
	http.Handle("/", http.FileServer(http.Dir("template")))
	// 设置接口处理文件传输
	http.HandleFunc("/uploadfile", uploadHandler)
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}

```

### 1.4. 302跳转

**简单跳转**

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func main() {
	// 直接跳转
	http.HandleFunc("/", http.RedirectHandler("http://1.1.1.1", http.StatusFound))

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

**特定目录跳转**

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 访问根转发到template
	if r.URL.Path == "/" {
		http.Redirect(w, r, "/template/", http.StatusFound)
		return
	}
	w.Write([]byte(r.URL.Path))
}

func main() {
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

### 1.5. 代理转发

- 定义tr忽略证书错误

```go
package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	// 访问根转发到template
	if r.URL.Path == "/" {
		http.Redirect(w, r, "/template/", http.StatusFound)
		return
	}

	// 请求转发给另一个url
	remote, err := url.Parse("https://1.1.1.1")
	if err != nil {
		log.Fatalln("serverAddr is invalid")
	}
	proxy := httputil.NewSingleHostReverseProxy(remote)

	// 忽略证书错误
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	proxy.Transport = tr

	proxy.ServeHTTP(w, r)
}

func main() {
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

### 1.4. 处理post的body数据

- json数据存在body里面
**<font color="red">`r.Body`只能读取一次，读完就会关闭，需要再次读取需要加上下面注释说明的代码</font>**

```go
package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
)

func rootHandler(w http.ResponseWriter, r *http.Request) {
	var body []byte
	if r.Body != nil {
		body, err = ioutil.ReadAll(r.Body)
		if err != nil {
			fmt.Println(err)
			return
		}
	}

	// 如果body想要多次读取需要加上下面的语句，重新申请一个readerCloser
	r.Body = ioutil.NopCloser(bytes.NewReader(body))
}

func main() {
	// 处理其他请求
	http.HandleFunc("/", rootHandler)

	log.Printf("start server: http://localhost:4567 ")
	err := http.ListenAndServe(":4567", nil)
	if err != nil {
		log.Fatal("Listen port failed, err: ", err)
	}
}
```

# 八、算法和数据结构的实现

## 1. 数据结构

### 1.1. 队列

- 可以使用`list.List`进行实现

```go
func main() {
	var test list.List
	// 入队列
	test.PushBack(1)
	test.PushBack(2)
	// 出队列
	value := test.Front().Value
	test.Remove(test.Front())
	fmt.Println(value)
	// 长度
	fmt.Println(test.Len())
	// 遍历
	for iter := test.Front(); iter != nil; iter = iter.Next() {
		fmt.Println(iter.Value)
	}
}
```

### 1.2. 栈

#### 1) list.List实现

```go
func main() {
	var test list.List
	// 入栈
	test.PushFront(1)
	test.PushFront(2)
	test.PushFront(3)
	// 出栈
	value := test.Front().Value
	test.Remove(test.Front())
	fmt.Println(value)
	// 长度
	fmt.Println(test.Len())
	// 从栈顶遍历
	for iter := test.Front(); iter != nil; iter = iter.Next() {
		fmt.Println(iter.Value)
	}
}
```

#### 2) slice实现

- slice实现有个好处就是，入栈会动态扩容，出栈容量会保留
- slice实现队列会导致重复内存申请

```go
func main() {
	test := []int{}
	// 入栈
	test = append(test, 1)
	test = append(test, 2)
	test = append(test, 3)
	// 出栈
	value := test[len(test)-1]
	test = test[:len(test)-1]
	fmt.Println(value)
	// 长度
	fmt.Println(len(test))
	// 从栈顶遍历
	for i := len(test); i > 0; i-- {
		fmt.Println(test[i-1])
	}
}
```

### 1.3. 链表

- 直接使用`list.List`就好，单向双向都支持

### 1.4. 大（小）根堆

- 官方库有heap，可以进行此操作，但是需要自己实现几个接口

```go
type BigHeap []int

func (h *BigHeap) Len() int { return len(*h) }

// less必须满足当Less(i, j)和Less(j, i)都为false，则两个索引对应的元素相等
//为true，i向栈顶移动；为false，j向栈顶移动
func (h *BigHeap) Less(i, j int) bool { return (*h)[i] > (*h)[j] }
func (h *BigHeap) Swap(i, j int)      { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] }
func (h *BigHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *BigHeap) Pop() interface{} {
	x := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return x
}

func main() {
	unorderList := BigHeap{12, 10, 4, 2, 5, 23, 45, 3, 9, 2}
	fmt.Println(unorderList)

	// 初始化大根堆
	heap.Init(&unorderList)
	// 堆排序，按照顺序一直将栈顶弹出，就为从大到小排序
	for unorderList.Len() > 0 {
		fmt.Println(heap.Pop(&unorderList))
	}
}
```

### 1.5. 二叉树

```go
type TreeNode struct {
	value int
	left *TreeNode
	right *TreeNode
}
```

## 2. 算法

### 2.1. 全排列

```go
func permutation(str []byte, index int, f func(str []byte)) {
	if len(str) == index {
		f(str)
		return
	}

	// 不交换的场景
	permutation(str, index+1, f)
	// index对应位置向后交换
	for i := index + 1; i < len(str); i++ {
		str[i], str[index] = str[index], str[i]
		permutation(str, index+1, f)
		str[i], str[index] = str[index], str[i]
	}
}

func main() {
	permutation([]byte("abcd"), 0, func(str []byte) {
		fmt.Println(string(str))
	})
}
```

### 2.2. bfs 广度优先算法

#### 1) 二叉树的广度优先遍历

```go
type TreeNode struct {
	value int
	left  *TreeNode
	right *TreeNode
}

func bfs(root *TreeNode) {
	var queue list.List
	queue.PushBack(&root)
	for queue.Len() > 0 {
		node := queue.Front().Value.(*TreeNode)
		queue.Remove(queue.Front())
		if node.left != nil {
			queue.PushBack(node.left)
		}
		if node.right != nil {
			queue.PushBack(node.right)
		}
		fmt.Println(node.value)	// 这里取值
	}
}
```

#### 2) 方格中找两点最短路径

- 两格之间步数为1，`#`作为墙不可走

```go
type pointT struct {
	x int
	y int
}

var (
	// 按照上下左右的相对位置设定，用于后面方便找四周的点
	kRoundPoints = [][]int{
		{0, -1},
		{0, 1},
		{-1, 0},
		{1, 0},
	}
)

// 返回从src到dst的最短路径长度，带层间隔版本
func bfsFloor(src pointT, dst pointT, grid []string) int {
	// 减小计算量，走过的路不再走，记录一下哪里走过了
	seen := make([][]bool, len(grid))
	for i := range seen {
		seen[i] = make([]bool, len(grid[0]))
	}
	// 源地址记录走过了，注意x是第二维的坐标
	seen[src.y][src.x] = true

	// 使用层数作为步数
	curDepth := 0
	var queue list.List
	// 插入源地址，作为第一层，使用nil作为层间隔
	queue.PushBack(src)
	queue.PushBack(nil)
	// 队列一定含有一个层间隔，不在头就在尾，如果只剩一个层间隔，说明没路可走
	for queue.Len() > 1 {
		tmp := queue.Front().Value
		queue.Remove(queue.Front())
		if tmp == nil {
			// 找到层间隔，说明当前层遍历完了，步数加一准备下一层
			curDepth++
			// 当前层遍历完，队列剩余的都是下一层，加入一个层间隔
			queue.PushBack(nil)
			continue
		}

		// 判断当前点是不是目标点，如果是，说明走到了，返回步数
		tx, ty := tmp.(pointT).x, tmp.(pointT).y
		if tx == dst.x && ty == dst.y {
			return curDepth
		}
		// 不是目标点，从此点出发，向四周走一下
		for i := range kRoundPoints {
			px, py := tx+kRoundPoints[i][0], ty+kRoundPoints[i][1]
			// 如果超出边界或者已经走过了或者碰到墙，就继续
			if py < 0 || py >= len(grid) || px < 0 || px >= len(grid[0]) || seen[py][px] || grid[py][px] == '#' {
				continue
			}
			// 这个点可以走，走上去，记录到队列中，作为下一层的起点
			seen[py][px] = true
			queue.PushBack(pointT{px, py})
		}
	}
	return -1
}

type pointST struct {
	x    int
	y    int
	step int
}

// 返回从src到dst的最短路径长度
func bfs(src pointST, dst pointST, grid []string) int {
	// 减小计算量，走过的路不再走，记录一下哪里走过了
	seen := make([][]bool, len(grid))
	for i := range seen {
		seen[i] = make([]bool, len(grid[0]))
	}
	// 源地址记录走过了，注意x是第二维的坐标
	seen[src.y][src.x] = true

	var queue list.List
	// 插入源地址
	queue.PushBack(src)
	for queue.Len() > 0 {
		tmp := queue.Front().Value.(pointST)
		queue.Remove(queue.Front())

		// 判断当前点是不是目标点，如果是，说明走到了，返回步数
		if tmp.x == dst.x && tmp.y == dst.y {
			return tmp.step
		}
		// 不是目标点，从此点出发，向四周走一下
		for i := range kRoundPoints {
			px, py := tmp.x+kRoundPoints[i][0], tmp.y+kRoundPoints[i][1]
			// 如果超出边界或者已经走过了或者碰到墙，就继续
			if py < 0 || py >= len(grid) || px < 0 || px >= len(grid[0]) || seen[py][px] || grid[py][px] == '#' {
				continue
			}
			// 这个点可以走，走上去，记录到队列中，作为下一层的起点
			seen[py][px] = true
			queue.PushBack(pointST{px, py, tmp.step+1})
		}
	}
	return -1
}

func main() {
	/*
		@ # . . *
		. . . # .
		# . . . .
	*/
	grid := []string{"@#..*", "...#.", "#...."}
	// @ 到 * 的最短距离为6
	fmt.Println(bfs(pointST{0, 0, 0}, pointST{4, 0, 0}, grid))
	fmt.Println(bfsFloor(pointT{0, 0}, pointT{4, 0}, grid))
}
```

# 踩坑记

## 1. 编译报错

### 1.1. method has pointer receiverd

- 由于定义的接口多个方法的接受不一致导致
- 部分方法实现使用了指针，部分使用了原始类型
- golang编译器发现`*T`类型实现了接口，调用的时候传入的又是`T`就给报错了
