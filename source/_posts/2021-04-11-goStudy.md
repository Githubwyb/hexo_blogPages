---
title: go语言学习
date: 2021-04-11 02:06:33
tags:
categories: [Program, Web]
---

# 一、前言

## 环境

```shell
=> go version
go version go1.16.4 linux/amd64
```

# 二、语法相关

## 1. 变量

### 1.1. 去除变量未定义提示

```go
_ = varA
```

### 1.2. 类型及转换

#### int

```go
// 转string
fmt.Sprint(123)
```

#### float32 float64

```go
// 转int
var f float32 = 1
var a int = int(f)
```

#### string

```go
// 转byte
var jsonStr string
jsonByte := []byte(jsonStr)
```

**单引号，双引号，反引号的区别**

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Printf("%c %d\n", 'a', 'a')
    fmt.Printf("a\n")
    fmt.Printf("%s\n", `a\n`)
}
```

输出

```shell
a 97
a
a\n
```

#### []byte

```go
// 转string
data := []byte("aaa")
str := string(data)
```

#### interface

**类型判断**

类型断言

```go
var f interface{}

if _, ok = f.(string); !ok {
	fmt.Println("f type is not string")
}
```

switch类型判断

```go
var f interface{}

switch(f.(type)) {
	case string:
		fmt.Println("f type is string")
		break

	case int:
		fmt.Println("f type is int")
		break

	default:
		fmt.Println("f type is unknown")
		break
}
```

## 2. map

### 2.1. 一些基本操作

```go
/****** map初始化 ******/
xxxMap := make(map[string]interface{})

/****** 判断map是否存在key ******/
if _, ok := xxxMap[key]; ok {
    // 存在key
}

/****** 遍历map ******/
for key, value := range xxxMap {
    // 操作map
}
```

### 注意事项

- `var xxx map[string]interface{}`定义的xxx是一个空指针，没有指向任何地址，不能进行赋值
- 初始化map需要使用make

## 3. array

### 3.1. 一些基本操作

```go
/****** array初始化 ******/
arr0 := [...]int{0, 1}
arr1 := [...]int{0, 1}
```

## 4. slice

### 4.1. 一些基本操作

```go
/****** slice初始化 ******/
s0 := []int{0, 1}
s1 := []int{0, 1}

/****** slice添加元素 ******/
// go对append有处理，如果赋值给原切片，且切片空间足够/，不会新申请内存
// 如果赋值给不同切片，会新申请内存，不会更改原切片
s0 = append(s0, 2)
s0 = append(s0, 3, 4)
// 切片合并，其中s1...意味着将s1拆分成元素传入append
// 相当于调用添加多个元素
s0 = append(s0, s1...)
```

## 4. 类型断言

# 三、标准库

## 1. json

### 1.1. 一些基本操作

```go
package main

import (
	"encoding/json"
)

func main() {
	/****** 将json字符串序列化成go对象 ******/
	// 先marshal在unmarshal可以让一个未知的interface确定内部类型
	// Unmarshal可以将一个json字符串解析到一个特定的格式下
	// json.Unmarshal会将数字解析成float64
	json.Unmarshal(jsonBytes, &target)

	/****** 将go对象转成json字符串 ******/
	var f interface{}
	jsonBytes, err := json.Marshal(&f)
	// 格式化的字符串，第二个是前缀，第三个是缩进符号
	jsonIndentBytes, err := json.MarshalIndent(&f, "", "    ")
}
```

### 1.2. key排序转json

- go默认对`map[string]interface{}`转json按照key升序转化
- 想要对key排序只能通过结构体的方式，转json会按照结构体的顺序转化
- 为空的key不想输出，可以加上`omitempty`

```go
type outT struct {
	Type string `json:"type,omitempty"`
	Name string `json:"name,omitempty"`
}

func main() {
	var f outT
	str, _ := json.Marshal(&f)	// {}
}
```

### 注意事项

- 数字类型在Unmarshal之后会转成float64，只能断言为float64

## 2. 单测 test

```go
package service

import (
	"encoding/json"
	"errors"
	"reflect"
	"sort"
	"testing"

	"github.com/gin-gonic/gin"

	. "github.com/agiledragon/gomonkey"
	. "github.com/smartystreets/goconvey/convey"
)

func TestFunc(t *testing.T) {
	sess := session.Session{}
	var s *session.Session

    // hook类的成员函数Commit
	patch := ApplyMethod(reflect.TypeOf(s), "Commit", func(_ *session.Session) error { return nil })
	defer patch.Reset()

    // 使用Convey包裹，可以按照分组测试
	Convey("TestFunc", t, func() {
		Convey("正常流程", func() {
			Convey("插入单个数据", func() {
				sess.New()
                ...
                // So确定
				So(tmp, ShouldResemble, []string{"aaa"})
			})
		})
		Convey("异常流程", func() {
			Convey("GetSessionData出错", func() {
				sess.New()
				...
				patch1 := ApplyMethod(reflect.TypeOf(s), "GetSessionData",
					func(_ *session.Session, _ string) (interface{}, error) {
						return nil, errors.New("testErr")
					})
				...
				So(tmp, ShouldResemble, []string{})
				patch1.Reset()
				...
				So(tmp, ShouldResemble, []string{"bbb"})
			})
		})
	})
}

```

## 3. flag

### 3.1. 获取命令行参数

```go
package main

import (
	"fmt"
	"flag"
)

func main() {
	// 在使用前先调用此函数解析参数，不然会返回空
	flag.Parse()
	// 打印第一个参数
	fmt.Println(flag.Arg(0))
	// 打印所有非flag的参数
	fmt.Println(flag.Args())
	// 打印参数个数
	fmt.Println(flag.NArg())
}
```

输出

```shell
=> go run main.go a -a -b -asdfsaf cccc
a
[a -a -b -asdfsaf ccc]
5
```

## 4. path/filepath 目录操作库

### 4.1. 遍历目录下所有文件和目录，类似 `find xxx`

```go
package main

import (
    "flag"
    "fmt"
    "os"
    "path/filepath"
)

func getFileList(path string) {
    err := filepath.Walk(path, func(path string, f os.FileInfo, err error) error {
        if f == nil {
            return err
        }
        if f.IsDir() {
            return nil
        }
        println(path)
        return nil
    })
    if err != nil {
        fmt.Printf("filepath.Walk() return %v\n", err)
    }
}

func main() {
    flag.Parse()
	var root string
    root = flag.Arg(0)
    getFileList(root)
}
```

输出

```shell
=> go run main.go .
go.mod
main.go
=> go run main.go ./
go.mod
main.go
=> go run main.go ../
../test/go.mod
../test/main.go
=> go run main.go /path/to/test
/path/to/test/go.mod
/path/to/test/main.go
```

## 5. os/exec 命令行调用

### 5.1. 阻塞式等待返回，并输出stdout

```go
package main

import (
    "bytes"
    "fmt"
    "os/exec"
)

func execShell(s string) (string, error) {
    cmd := exec.Command("/bin/bash", "-c", s)

    var out bytes.Buffer
    cmd.Stdout = &out

    err := cmd.Run()
    if err != nil {
        fmt.Printf("%v\n", err)
    }

    return out.String(), err
}

func main() {
    fmt.Println(execShell("ls /"))
}
```

## 6. net/http 网络请求库

### 6.1. 发送post请求

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func main() {
	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
    if err != nil {
        fmt.Println(err)
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(string(body))
}
```

### 6.2. 忽略https的证书错误

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
    "crypto/tls"
)

func main() {
	http.DefaultClient.Transport = &http.Transport{
        TLSClientConfig: &tls.Config{
            InsecureSkipVerify: true,
        },
    }

	resp, err := http.Post("https://1.1.1.1:1234/a/b", "application/x-www-form-urlencoded", strings.NewReader("mobileId=!@#$%^"))
	...
}
```

### 6.3. 搭建简单http服务器

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

type retJson struct {
	Code  int    `json:"code"`
	LLLL  string `json:"llll"`
	AAAA  string `json:"aaaa"`
	Token string `json:"token"`
}

func smsServerHandler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	fmt.Println(r.Form)
	fmt.Println("path", r.URL.Path)
	fmt.Println("scheme", r.URL.Scheme)

	var ret retJson
	ret.Code = 0
	ret.LLLL = "test"
	ret.AAAA = "stest"
	ret.Token = "a454as1bbvd5g5s15155"
	retBytes, _ := json.MarshalIndent(&ret, "", "    ")
	retStr := string(retBytes)
	fmt.Println(retStr)

	w.Header().Set("Content-Type", "application-json")
	fmt.Fprintf(w, retStr)
}

func main() {
	http.HandleFunc("/", smsServerHandler)
	err := http.ListenAndServe(":7878", nil)
	if err != nil {
		log.Fatal("ListenAndServe failed, err: ", err)
	}
}
```

## 7. strings 字符串操作库

### 7.1. 字符串替换

```go
package main

import (
	"strings"
)

func main() {
	outStr := '{"a":"123"}'
	// 将json中的双引号全部替换为单引号
	outStr = strings.ReplaceAll(outStr, `"`, `'`)
}
```

# 四、框架

## 1. 工程知识

### 1.1. go.mod

- `go.mod`是go工程用来管理包使用的，类似于nodejs的`package.json`文件

#### (1) 创建新工程

**1. 先生成go.mod文件**

```shell
# 初始化一个test工程
go mod init test
```

#### (2) go mod 一些基本操作

```shell
# 添加工程依赖包，会加入到go.mod文件中的require中
go mod download github.com/mattn/go-sqlite3
# 根据go.mod文件处理依赖关系
go mod tidy
```

## 2. goframe

### 2.1. 安装配置

**安装gf命令行工具**

- goframe安装需要一个gf命令行工具

```shell
# 下载安装gf
wget -O gf https://github.com/gogf/gf-cli/releases/download/v1.16.3/gf_linux_amd64 && chmod +x gf && ./gf install
```

- 默认gf命令行工具不支持sqlite3，如果需要，上面安装完之后，自己编译一版sqlite3的gf工具
- 确保有gcc编译环境

```shell
# clone仓库
git clone https://github.com/gogf/gf-cli && cd gf-cli
# 设置环境变量
export CGO_ENABLED=1
# 将代码中的sqlite3依赖取消注释
vim command/gen/gen_dao.go
...
# 执行gf的编译命令，需要上述步骤先下载gf工具
# -a指定平台，可以编译下面几种平台
#       darwin    amd64,arm64
#       freebsd   386,amd64,arm
#       linux     386,amd64,arm,arm64,ppc64,ppc64le,mips,mipsle,mips64,mips64le
#       netbsd    386,amd64,arm
#       openbsd   386,amd64,arm
#       windows   386,amd64
gf build main.go -a amd64 -s linux --cgo
# 安装
cp bin/linux_amd64/gf /usr/local/bin/gf
```

**初始化**

- 如果需要使用sqlite3，需要在项目根目录执行

```shell
go mod download github.com/mattn/go-sqlite3
```

**代码生成**

- 根据`config.toml`生成数据库代码，这个比较方便

```shell
gf gen dao -c config/config.toml
```

### 2.2. 开发知识点

#### 2.2.1. orm时间维护功能

- orm的数据库更新操作会自动更新updatedAt、createdAt、deletedAt等字段
- 不想要更新字段需要加上`Unscoped()`

```go
db.Table("user").Unscoped().Data(g.Map{"name" : "john guo"}).Where("name", "john").Update()
```

### 2.2.2. 前后端字段对应

- gf中使用下面的方法可以将前端传入参数解析到struct的对应成员中

```go
// app/model/xxx.go
type TaskApiCreateReq struct {
	Content  string `json:"content" v:"required|length:1,100#任务内容不能为空|任务内容应当在:min到:max之间"`
	TaskType int    `json:"taskType"`
}
// app/api/xxx.go
func (a *task) Create(r *ghttp.Request) {
	var (
		data *model.TaskApiCreateReq
	)
	if err := r.Parse(&data); err != nil {
		response.JsonExit(r, 1, err.Error())
	}
	...
}
```

- 解析规则，会把前端传入的字段去除除了字母和数字的所有特殊字符，然后不区分大小写比较
- 下面的几个key都可以解析到上面的`data.Content`中

```json
{
	"Content": "xxx",
	"content": "xxx",
	"con_tent": "xxx",
	"conTent": "xxx"
}
```

### 踩坑记
