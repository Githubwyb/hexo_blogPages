---
title: C++学习笔记
date: 2018-07-06 19:23:23
tags: [study, notes]
categories: [notes, study]
---

# 学习记录

## std::string

### data()和c_str()区别

data()效率较c_str()高一些，但是c_str()更加标准，结尾会加入'\0'。

# 错误总结

## 头文件不要using namespace

头文件使用`using namespace`会污染所有包含此头文件的文件

## 参数传递看情况使用引用

```C++
    type function(const type &arg);
```

- 引用的形式可以减少复制的过程
- 我自己的想法是对于超过int大小的变量使用引用的形式来传参。
- 对于部分对外的参数可以不使用引用比如

```C++
    const std::string toJson();
```

## const的使用

### 外部不可更改

对于引用传递的参数，为防止外部修改，加const修饰。

```C++
    const type &getArg();
```

### 内部不可更改

对于get方法等内部参数不会被修改的方法，在后部加const修饰

```C++
    const std::string toJson() const;
```

## 参数赋值必须用自己的类型

```C++
    //错误方式
    bool arg = 1;
    //正确方式
    bool arg = true;
```

## 类的建立需要添加构造函数和删除构造函数

拷贝构造函数，允许被拷贝才需要添加

```C++
    class temp
    {
        public:
            //允许拷贝
            temp(const temp &a) = default;
            //不允许拷贝
            temp(const temp &a) = delete;
    };
```

## 类的内部属性需要初始化

在参数声明的地方初始化，参数列表是给自己写的构造函数用的，并根据需要删除或声明为私有默认构造函数。

```C++
//hpp
    class temp
    {
        public:
            temp(const type1 &a);
            //如果需要
            temp() = delete;
        private:
            //或者
            temp();

            type1 m_arg1 = type1InitValue;
            type2 m_arg2 = type2InitValue;
            type3 m_arg3 = type3InitValue;
    };

//cpp
temp::temp(const type1 &a) : m_arg1(a);
```

## 单例构建

base/BaseInstance.hpp 为一个模板类，用来给需要写为单例的类使用

```C++
    #ifndef BaseInstance_hpp
    #define BaseInstance_hpp

    namespace cb {
        class BaseNoCopy {
        public:
            BaseNoCopy(){ }
        private:
            BaseNoCopy(const BaseNoCopy &obj);
            BaseNoCopy(BaseNoCopy *pObj);
            BaseNoCopy(const BaseNoCopy *pObj);
            BaseNoCopy& operator = (const BaseNoCopy &obj);
            BaseNoCopy& operator = (const BaseNoCopy *pObj);
        };


        template <class T> class BaseInstance: public BaseNoCopy {
        public:
            static T &getInstance() {
                static T s_instance;
                CreateObject.do_nothing();

                return s_instance;
            }
        protected:
            BaseInstance(){ }
        private:
            BaseInstance(const BaseInstance &obj);
            BaseInstance operator = (const BaseInstance &obj);

            struct ObjectCreator {
                ObjectCreator() {
                    BaseInstance<T>::getInstance();
                }

                inline void do_nothing()const{ }
            };
            static ObjectCreator CreateObject;
        };

        template <typename T>
        typename BaseInstance<T>::ObjectCreator BaseInstance<T>::CreateObject;
    }

    #endif /* BaseInstance_hpp */
```

使用方法

```C++
    class temp : public BaseInstance<temp>
    {
        ...
    }
```
