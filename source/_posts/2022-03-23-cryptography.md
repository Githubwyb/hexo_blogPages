---
title: 密码学原理和实现（go版本）笔记
date: 2022-03-23 17:30:58
tags:
categories: [Program, go]
---

# 一、名词解释

## 1. HMAC

**全称**

- Hash-based Message Authentication Code
- 散列消息认证码

**说明**

- 使用密码散列函数，结合加密密钥，计算成的消息认证码，主要用于保证数据完整性，同时作为消息的身份认证

## 2. SHA256

**全称**

- Secure Hash Algorithm 256
- 安全散列算法256

**说明**

- 散列函数的一种，对任意长度的数字，计算一个32byte（256bit）的字符串（message digest）

## 3. RSA

**全称**

- Rivest-Shamir-Adleman
- 三个人提出的一种加解密算法

**说明**

- 使用不同的加密密钥和解密密钥
- 已知加密密钥无法推导出解密密钥

# 二、基本数学知识

## 1. gcd 最大公约数

**全称**

- Greatest Common Divisor

## 2. 互质关系

**概念**

两个数的最大公约数是1，就是互质关系

**说明**

- 任意两个质数构成互质关系，比如13和61。
- 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。
- 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。
- 1和任意一个自然数是都是互质关系，比如1和99。
- p是大于1的整数，则p和p-1构成互质关系，比如57和56。
- p是大于1的奇数，则p和p-2构成互质关系，比如17和15。

## 3. $a \equiv 1 (mod\ n)$

代表 $a\ mod\ n = 1$

**概念**

如果两个正整数 $a$ 和 $n$ 互质，那么一定可以找到整数 $b$，使得 $ab\ mod\ n = 1$

# 三、算法描述和实现

## 1. HMAC-SHA256

- 使用SHA256生成hash值的HMAC算法

### 1.1. 算法步骤

摘自[从零入门HMAC-SHA256](https://blog.csdn.net/sdnyqfyqf/article/details/105534376)

<img src="2022-03-23-01.png" />

1. 密钥填充。若密钥比SHA-256算法的分组长度B（512-bit）短，则需在末尾填充0，直到其长度达到单向散列函数的分组长度为止。若密钥比分组长度长，则要用SHA-256算法求出密钥的散列值，然后将这个散列值作为新的密钥；
2. 内部填充。将填充后的密钥与被称为ipad的序列进行异或运算，所形成的值为ipadkey。ipad是将00110110这一序列不断循环反复直到达到分组长度；
3. 与消息组合。将ipadkey与消息组合，也就是将ipadkey附加在消息的开头。
4. 计算散列值。将3的结果输入SHA-256函数，并计算出散列值。
5. 外部填充。将填充后的密钥与被称为opad的序列进行异或运算，所形成的值为opadkey。opad是将01011100这一序列不断循环反复直到达到分组长度。
6. 与散列值组合。将4的散列值拼在opadkey后面。
7. 计算散列值。将6的结果输入SHA-256函数，并计算出散列值，这个散列值就是最终的摘要内容。

### 1.2. go的上层实现

```go
package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

func main() {
	key := "aaaaa"
    str_to_sign := "bbbb"

	sig := hmac.New(sha256.New, []byte(key))
	sig.Write([]byte(str_to_sign))
	fmt.Println(hex.EncodeToString(sig.Sum(nil)))
}
```

## 2. RSA算法

- 参考自 [RSA算法原理](https://zhuanlan.zhihu.com/p/48249182)

### 2.1. 算法原理

- 找到两个大素数，由于他们的因式分解很困难，可以将乘积公开作为加密密钥

### 2.2. 算法描述

1. 任意选取两个不同的大素数 $p$ 和 $q$，计算得到 $n = pq, \varphi(n) = (p-1)(q-1)$
2. 选取一个大整数 $e$ 作为**加密密钥**，满足 $gcd(e, \varphi(n))=1$，所有大于 $p$ 和 $q$ 的素数都可用做 $e$
3. 确定 $d$ 作为**解密密钥**，满足 $(de)\ mod\ \varphi(n) = 1$，即 $de = k\varphi(n) + 1, k \ge 1$，所以，知道 $e$ 和 $\varphi(n)$ 很容易计算出d
4. 公开整数 $n$ 和 $e$，保存 $d$
5. 将明文 $m$ 加密成密文 $c$，算法为 $c = E(m) = m^e\ mod\ n$
6. 密文 $c$ 解密成明文 $m$，算法为 $m = D(c) = c^d\ mod\ n$

### 2.3. 算法证明

## 3. ECDHE算法

参考 [ECC椭圆曲线详解(有具体实例)](https://www.cnblogs.com/Kalafinaian/p/7392505.html)

### 3.1. 算法原理

- 通俗来讲，就是定义了一个椭圆曲线上两个点加法的运算，得到的结果也是椭圆曲线上的一个点
- 由于椭圆曲线上此加法满足交换律、结合律
- 离散域里面将椭圆曲线和mod结合起来，还是满足交换律和结合律
- 私钥就是随机选择的一个数d，确定椭圆曲线和椭圆曲线的基点G，公钥就满足

$$
Q = G + G + ... + G = dG
$$

- 两个端分别有 $d_1$ 和 $d_2$，分别基于G算出 $Q_1$ 和 $Q_2$，满足下面的式子

$$
d_1Q_2 = d_1d_2G = d_2d_1G = d_2Q_1
$$

- 两边使用对方的公钥和自己的私钥就可以计算出一个共同的点`(x, y)`，其中的x是一样的，这样的x就可以作为对称加密密钥
